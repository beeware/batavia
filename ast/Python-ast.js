/* File automatically generated by ast/asdl_js.py. */

(function() {
function mod_type() {};
function Module_type() {};
var body = 'body';
var Module_fields = [
    "body",
];
function Interactive_type() {};
var Interactive_fields = [
    "body",
];
function Expression_type() {};
var Expression_fields = [
    "body",
];
function Suite_type() {};
var Suite_fields = [
    "body",
];
function stmt_type() {};
var lineno = 'lineno';
var col_offset = 'col_offset';
var stmt_attributes = [
    "lineno",
    "col_offset",
];
function FunctionDef_type() {};
var name = 'name';
var args = 'args';
var decorator_list = 'decorator_list';
var returns = 'returns';
var FunctionDef_fields = [
    "name",
    "args",
    "body",
    "decorator_list",
    "returns",
];
function AsyncFunctionDef_type() {};
var AsyncFunctionDef_fields = [
    "name",
    "args",
    "body",
    "decorator_list",
    "returns",
];
function ClassDef_type() {};
var bases = 'bases';
var keywords = 'keywords';
var ClassDef_fields = [
    "name",
    "bases",
    "keywords",
    "body",
    "decorator_list",
];
function Return_type() {};
var value = 'value';
var Return_fields = [
    "value",
];
function Delete_type() {};
var targets = 'targets';
var Delete_fields = [
    "targets",
];
function Assign_type() {};
var Assign_fields = [
    "targets",
    "value",
];
function AugAssign_type() {};
var target = 'target';
var op = 'op';
var AugAssign_fields = [
    "target",
    "op",
    "value",
];
function For_type() {};
var iter = 'iter';
var orelse = 'orelse';
var For_fields = [
    "target",
    "iter",
    "body",
    "orelse",
];
function AsyncFor_type() {};
var AsyncFor_fields = [
    "target",
    "iter",
    "body",
    "orelse",
];
function While_type() {};
var test = 'test';
var While_fields = [
    "test",
    "body",
    "orelse",
];
function If_type() {};
var If_fields = [
    "test",
    "body",
    "orelse",
];
function With_type() {};
var items = 'items';
var With_fields = [
    "items",
    "body",
];
function AsyncWith_type() {};
var AsyncWith_fields = [
    "items",
    "body",
];
function Raise_type() {};
var exc = 'exc';
var cause = 'cause';
var Raise_fields = [
    "exc",
    "cause",
];
function Try_type() {};
var handlers = 'handlers';
var finalbody = 'finalbody';
var Try_fields = [
    "body",
    "handlers",
    "orelse",
    "finalbody",
];
function Assert_type() {};
var msg = 'msg';
var Assert_fields = [
    "test",
    "msg",
];
function Import_type() {};
var names = 'names';
var Import_fields = [
    "names",
];
function ImportFrom_type() {};
var module = 'module';
var level = 'level';
var ImportFrom_fields = [
    "module",
    "names",
    "level",
];
function Global_type() {};
var Global_fields = [
    "names",
];
function Nonlocal_type() {};
var Nonlocal_fields = [
    "names",
];
function Expr_type() {};
var Expr_fields = [
    "value",
];
function Pass_type() {};
function Break_type() {};
function Continue_type() {};
function expr_type() {};
var expr_attributes = [
    "lineno",
    "col_offset",
];
function BoolOp_type() {};
var values = 'values';
var BoolOp_fields = [
    "op",
    "values",
];
function BinOp_type() {};
var left = 'left';
var right = 'right';
var BinOp_fields = [
    "left",
    "op",
    "right",
];
function UnaryOp_type() {};
var operand = 'operand';
var UnaryOp_fields = [
    "op",
    "operand",
];
function Lambda_type() {};
var Lambda_fields = [
    "args",
    "body",
];
function IfExp_type() {};
var IfExp_fields = [
    "test",
    "body",
    "orelse",
];
function Dict_type() {};
var keys = 'keys';
var Dict_fields = [
    "keys",
    "values",
];
function Set_type() {};
var elts = 'elts';
var Set_fields = [
    "elts",
];
function ListComp_type() {};
var elt = 'elt';
var generators = 'generators';
var ListComp_fields = [
    "elt",
    "generators",
];
function SetComp_type() {};
var SetComp_fields = [
    "elt",
    "generators",
];
function DictComp_type() {};
var key = 'key';
var DictComp_fields = [
    "key",
    "value",
    "generators",
];
function GeneratorExp_type() {};
var GeneratorExp_fields = [
    "elt",
    "generators",
];
function Await_type() {};
var Await_fields = [
    "value",
];
function Yield_type() {};
var Yield_fields = [
    "value",
];
function YieldFrom_type() {};
var YieldFrom_fields = [
    "value",
];
function Compare_type() {};
var ops = 'ops';
var comparators = 'comparators';
var Compare_fields = [
    "left",
    "ops",
    "comparators",
];
function Call_type() {};
var func = 'func';
var Call_fields = [
    "func",
    "args",
    "keywords",
];
function Num_type() {};
var n = 'n';
var Num_fields = [
    "n",
];
function Str_type() {};
var s = 's';
var Str_fields = [
    "s",
];
function FormattedValue_type() {};
var conversion = 'conversion';
var format_spec = 'format_spec';
var FormattedValue_fields = [
    "value",
    "conversion",
    "format_spec",
];
function JoinedStr_type() {};
var JoinedStr_fields = [
    "values",
];
function Bytes_type() {};
var Bytes_fields = [
    "s",
];
function NameConstant_type() {};
var NameConstant_fields = [
    "value",
];
function Ellipsis_type() {};
function Constant_type() {};
var Constant_fields = [
    "value",
];
function Attribute_type() {};
var attr = 'attr';
var ctx = 'ctx';
var Attribute_fields = [
    "value",
    "attr",
    "ctx",
];
function Subscript_type() {};
var slice = 'slice';
var Subscript_fields = [
    "value",
    "slice",
    "ctx",
];
function Starred_type() {};
var Starred_fields = [
    "value",
    "ctx",
];
function Name_type() {};
var id = 'id';
var Name_fields = [
    "id",
    "ctx",
];
function List_type() {};
var List_fields = [
    "elts",
    "ctx",
];
function Tuple_type() {};
var Tuple_fields = [
    "elts",
    "ctx",
];
function expr_context_type() {};
function Load_type() {};
function Store_type() {};
function Del_type() {};
function AugLoad_type() {};
function AugStore_type() {};
function Param_type() {};
function slice_type() {};
function Slice_type() {};
var lower = 'lower';
var upper = 'upper';
var step = 'step';
var Slice_fields = [
    "lower",
    "upper",
    "step",
];
function ExtSlice_type() {};
var dims = 'dims';
var ExtSlice_fields = [
    "dims",
];
function Index_type() {};
var Index_fields = [
    "value",
];
function boolop_type() {};
function And_type() {};
function Or_type() {};
function operator_type() {};
function Add_type() {};
function Sub_type() {};
function Mult_type() {};
function MatMult_type() {};
function Div_type() {};
function Mod_type() {};
function Pow_type() {};
function LShift_type() {};
function RShift_type() {};
function BitOr_type() {};
function BitXor_type() {};
function BitAnd_type() {};
function FloorDiv_type() {};
function unaryop_type() {};
function Invert_type() {};
function Not_type() {};
function UAdd_type() {};
function USub_type() {};
function cmpop_type() {};
function Eq_type() {};
function NotEq_type() {};
function Lt_type() {};
function LtE_type() {};
function Gt_type() {};
function GtE_type() {};
function Is_type() {};
function IsNot_type() {};
function In_type() {};
function NotIn_type() {};
function comprehension_type() {};
var ifs = 'ifs';
var comprehension_fields =[
    "target",
    "iter",
    "ifs",
];
function excepthandler_type() {};
var excepthandler_attributes = [
    "lineno",
    "col_offset",
];
function ExceptHandler_type() {};
var type = 'type';
var ExceptHandler_fields = [
    "type",
    "name",
    "body",
];
function arguments_type() {};
var vararg = 'vararg';
var kwonlyargs = 'kwonlyargs';
var kw_defaults = 'kw_defaults';
var kwarg = 'kwarg';
var defaults = 'defaults';
var arguments_fields =[
    "args",
    "vararg",
    "kwonlyargs",
    "kw_defaults",
    "kwarg",
    "defaults",
];
function arg_type() {};
var arg_attributes = [
    "lineno",
    "col_offset",
];
var arg = 'arg';
var annotation = 'annotation';
var arg_fields =[
    "arg",
    "annotation",
];
function keyword_type() {};
var keyword_fields =[
    "arg",
    "value",
];
function alias_type() {};
var asname = 'asname';
var alias_fields =[
    "name",
    "asname",
];
function withitem_type() {};
var context_expr = 'context_expr';
var optional_vars = 'optional_vars';
var withitem_fields =[
    "context_expr",
    "optional_vars",
];



var AST_object = function() {
    this.dict = new batavia.types.Dict();
};

AST_object.prototype = Object.create(Object.prototype);
AST_object.prototype.__class__ = new batavia.types.Type('AST_object');

AST_object.prototype.traverse = function(visit, arg) {
    Py_VISIT(this.dict);
};

AST_object.prototype.ast_clear = function() {
    this.dict.clear();
};

AST_object.prototype.init = function(args, kwarg) {
    _Py_IDENTIFIER(_fields);
    var i;
    var numfields = 0;
    var res = -1;
    var key = null;
    var value = null;
    var fields = null;
    fields = _PyObject_GetAttrId(Py_TYPE(self), PyId__fields);
    if (!fields)
        PyErr_Clear();
    if (fields) {
        numfields = PySequence_Size(fields);
        if (numfields == -1)
            return res;
    }
    res = 0; /* if no error occurs, this stays 0 to the end */
    if (PyTuple_GET_SIZE(args) > 0) {
        if (numfields != PyTuple_GET_SIZE(args)) {
            throw new batavia.builtins.TypeError(Py_TYPE(self).tp_name + " constructor takes " + (numfields == 0 ? "" : "either 0 or ") +
                         numfield + " positional argument " + (numfields == 1 ? "" : "s"));
            res = -1;
            return res;
        }
        for (i = 0; i < PyTuple_GET_SIZE(args); i++) {
            /* cannot be reached when fields is null */
            var name = PySequence_GetItem(fields, i);
            if (!name) {
                res = -1;
                return res;
            }
            res = PyObject_SetAttr(self, name, PyTuple_GET_ITEM(args, i));
            if (res < 0)
                return res;
        }
    }
    if (kw) {
        i = 0;  /* needed by PyDict_Next */
        while (PyDict_Next(kw, i, key, value)) {
            res = PyObject_SetAttr(self, key, value);
            if (res < 0)
                return res;
        }
    }
    return res;
};

/* Pickling support */
AST_object.prototype.reduce = function(unused) {
    var res = null;
    _Py_IDENTIFIER(__dict__);
    var dict = _PyObject_GetAttrId(self, PyId___dict__);
    if (dict == null) {
        if (PyErr_ExceptionMatches(PyExc_AttributeError))
            PyErr_Clear();
        else
            return null;
    }
    if (dict) {
        res = Py_BuildValue("O()O", Py_TYPE(self), dict);
        return res;
    }
    return Py_BuildValue("O()", Py_TYPE(self));
};

var make_type = function(type, base, fields) {
    var fnames = new batavia.types.Tuple(fields || []);
    return new batavia.types.Type('Tokenizer', base, fields);
};

var add_attributes = function(type, attrs) {
    var l = new batavia.types.Tuple(attrs || []);
    type._attributes = l;
};



batavia.modules.ast = {};
batavia.modules.ast.AST_object = AST_object;

/* Conversion AST -> Python */

var ast2obj_list = function(seq, func) {
    var i = 0;
    var n = asdl_seq_LEN(seq);
    var result = PyList_New(n);
    var value = null;
    if (!result)
        return null;
    for (var i = 0; i < n; i++) {
        value = func(asdl_seq_GET(seq, i));
        if (!value) {
            return null;
        }
        PyList_SET_ITEM(result, i, value);
    }
    return result;
};

var ast2obj_int = function(b) {
    return new batavia.types.Int(b);
};

/* Conversion Python -> AST */

var obj2ast_singleton = function(obj) {
    if (obj != null && !batavia.isinstance(obj, batavia.types.Bool)) {
        throw new batavia.builtins.ValueError("AST singleton must be True, False, or None");
    }
    return obj;
};

var obj2ast_object = function(obj) {
    return obj;
};

var obj2ast_constant = function(obj) {
    return obj;
};

var obj2ast_identifier = function(obj) {
    if (!batavia.isinstance(obj, batavia.types.Str) && obj != null) {
        throw new batavia.builtins.TypeError("AST identifier must be of type str");
    }
    return obj2ast_object(obj);
};

var obj2ast_string = function(obj) {
    if (!batavia.isinstance(obj, [batavia.types.Bytes, batavia.types.Str])) {
        throw new batavia.builtins.TypeError("AST string must be of type str");
    }
    return obj2ast_object(obj);
}

var obj2ast_bytes = function(obj) {
    if (!batavia.isinstance(obj, batavia.types.Bytes)) {
        throw new batavia.builtins.TypeError("AST bytes must be of type bytes");
    }
    return obj2ast_object(obj);
};

var obj2ast_int = function(obj) {
    if (!batavia.isinstance(obj, [batavia.types.Int])) {
        throw new batavia.builtins.ValueError("invalid integer value: ", obj);
    }
    return obj.int32();
};

var add_ast_fields = function() {
    var empty_tuple = new batavia.types.Tuple();
    AST_object._fields = empty_tuple;
    AST_object._attributed = empty_tuple;
};

var exists_not_none = function(obj, id) {
    var isnone = null;
    var attr = obj.id;
    if (!attr) {
        return;
    }
    isnone = attr == null;
    return !isnone;
};

var init_types = function() {
    if (this.initialized) return 1;
    if (add_ast_fields() < 0) return 0;
    mod_type.prototype.__class__ = make_type("mod", AST_object, null);
    if (!mod_type) return 0;
    add_attributes(mod_type, null, 0);
    Module_type.prototype.__class__ = make_type("Module", mod_type, Module_fields);
    if (!Module_type) return 0;
    Interactive_type.prototype.__class__ = make_type("Interactive", mod_type, Interactive_fields);
    if (!Interactive_type) return 0;
    Expression_type.prototype.__class__ = make_type("Expression", mod_type, Expression_fields);
    if (!Expression_type) return 0;
    Suite_type.prototype.__class__ = make_type("Suite", mod_type, Suite_fields);
    if (!Suite_type) return 0;
    stmt_type.prototype.__class__ = make_type("stmt", AST_object, null);
    if (!stmt_type) return 0;
    add_attributes(stmt_type, stmt_attributes, 2);
    FunctionDef_type.prototype.__class__ = make_type("FunctionDef", stmt_type, FunctionDef_fields);
    if (!FunctionDef_type) return 0;
    AsyncFunctionDef_type.prototype.__class__ = make_type("AsyncFunctionDef", stmt_type, AsyncFunctionDef_fields);
    if (!AsyncFunctionDef_type) return 0;
    ClassDef_type.prototype.__class__ = make_type("ClassDef", stmt_type, ClassDef_fields);
    if (!ClassDef_type) return 0;
    Return_type.prototype.__class__ = make_type("Return", stmt_type, Return_fields);
    if (!Return_type) return 0;
    Delete_type.prototype.__class__ = make_type("Delete", stmt_type, Delete_fields);
    if (!Delete_type) return 0;
    Assign_type.prototype.__class__ = make_type("Assign", stmt_type, Assign_fields);
    if (!Assign_type) return 0;
    AugAssign_type.prototype.__class__ = make_type("AugAssign", stmt_type, AugAssign_fields);
    if (!AugAssign_type) return 0;
    For_type.prototype.__class__ = make_type("For", stmt_type, For_fields);
    if (!For_type) return 0;
    AsyncFor_type.prototype.__class__ = make_type("AsyncFor", stmt_type, AsyncFor_fields);
    if (!AsyncFor_type) return 0;
    While_type.prototype.__class__ = make_type("While", stmt_type, While_fields);
    if (!While_type) return 0;
    If_type.prototype.__class__ = make_type("If", stmt_type, If_fields);
    if (!If_type) return 0;
    With_type.prototype.__class__ = make_type("With", stmt_type, With_fields);
    if (!With_type) return 0;
    AsyncWith_type.prototype.__class__ = make_type("AsyncWith", stmt_type, AsyncWith_fields);
    if (!AsyncWith_type) return 0;
    Raise_type.prototype.__class__ = make_type("Raise", stmt_type, Raise_fields);
    if (!Raise_type) return 0;
    Try_type.prototype.__class__ = make_type("Try", stmt_type, Try_fields);
    if (!Try_type) return 0;
    Assert_type.prototype.__class__ = make_type("Assert", stmt_type, Assert_fields);
    if (!Assert_type) return 0;
    Import_type.prototype.__class__ = make_type("Import", stmt_type, Import_fields);
    if (!Import_type) return 0;
    ImportFrom_type.prototype.__class__ = make_type("ImportFrom", stmt_type, ImportFrom_fields);
    if (!ImportFrom_type) return 0;
    Global_type.prototype.__class__ = make_type("Global", stmt_type, Global_fields);
    if (!Global_type) return 0;
    Nonlocal_type.prototype.__class__ = make_type("Nonlocal", stmt_type, Nonlocal_fields);
    if (!Nonlocal_type) return 0;
    Expr_type.prototype.__class__ = make_type("Expr", stmt_type, Expr_fields);
    if (!Expr_type) return 0;
    Pass_type.prototype.__class__ = make_type("Pass", stmt_type, null);
    if (!Pass_type) return 0;
    Break_type.prototype.__class__ = make_type("Break", stmt_type, null);
    if (!Break_type) return 0;
    Continue_type.prototype.__class__ = make_type("Continue", stmt_type, null);
    if (!Continue_type) return 0;
    expr_type.prototype.__class__ = make_type("expr", AST_object, null);
    if (!expr_type) return 0;
    add_attributes(expr_type, expr_attributes, 2);
    BoolOp_type.prototype.__class__ = make_type("BoolOp", expr_type, BoolOp_fields);
    if (!BoolOp_type) return 0;
    BinOp_type.prototype.__class__ = make_type("BinOp", expr_type, BinOp_fields);
    if (!BinOp_type) return 0;
    UnaryOp_type.prototype.__class__ = make_type("UnaryOp", expr_type, UnaryOp_fields);
    if (!UnaryOp_type) return 0;
    Lambda_type.prototype.__class__ = make_type("Lambda", expr_type, Lambda_fields);
    if (!Lambda_type) return 0;
    IfExp_type.prototype.__class__ = make_type("IfExp", expr_type, IfExp_fields);
    if (!IfExp_type) return 0;
    Dict_type.prototype.__class__ = make_type("Dict", expr_type, Dict_fields);
    if (!Dict_type) return 0;
    Set_type.prototype.__class__ = make_type("Set", expr_type, Set_fields);
    if (!Set_type) return 0;
    ListComp_type.prototype.__class__ = make_type("ListComp", expr_type, ListComp_fields);
    if (!ListComp_type) return 0;
    SetComp_type.prototype.__class__ = make_type("SetComp", expr_type, SetComp_fields);
    if (!SetComp_type) return 0;
    DictComp_type.prototype.__class__ = make_type("DictComp", expr_type, DictComp_fields);
    if (!DictComp_type) return 0;
    GeneratorExp_type.prototype.__class__ = make_type("GeneratorExp", expr_type, GeneratorExp_fields);
    if (!GeneratorExp_type) return 0;
    Await_type.prototype.__class__ = make_type("Await", expr_type, Await_fields);
    if (!Await_type) return 0;
    Yield_type.prototype.__class__ = make_type("Yield", expr_type, Yield_fields);
    if (!Yield_type) return 0;
    YieldFrom_type.prototype.__class__ = make_type("YieldFrom", expr_type, YieldFrom_fields);
    if (!YieldFrom_type) return 0;
    Compare_type.prototype.__class__ = make_type("Compare", expr_type, Compare_fields);
    if (!Compare_type) return 0;
    Call_type.prototype.__class__ = make_type("Call", expr_type, Call_fields);
    if (!Call_type) return 0;
    Num_type.prototype.__class__ = make_type("Num", expr_type, Num_fields);
    if (!Num_type) return 0;
    Str_type.prototype.__class__ = make_type("Str", expr_type, Str_fields);
    if (!Str_type) return 0;
    FormattedValue_type.prototype.__class__ = make_type("FormattedValue", expr_type, FormattedValue_fields);
    if (!FormattedValue_type) return 0;
    JoinedStr_type.prototype.__class__ = make_type("JoinedStr", expr_type, JoinedStr_fields);
    if (!JoinedStr_type) return 0;
    Bytes_type.prototype.__class__ = make_type("Bytes", expr_type, Bytes_fields);
    if (!Bytes_type) return 0;
    NameConstant_type.prototype.__class__ = make_type("NameConstant", expr_type, NameConstant_fields);
    if (!NameConstant_type) return 0;
    Ellipsis_type.prototype.__class__ = make_type("Ellipsis", expr_type, null);
    if (!Ellipsis_type) return 0;
    Constant_type.prototype.__class__ = make_type("Constant", expr_type, Constant_fields);
    if (!Constant_type) return 0;
    Attribute_type.prototype.__class__ = make_type("Attribute", expr_type, Attribute_fields);
    if (!Attribute_type) return 0;
    Subscript_type.prototype.__class__ = make_type("Subscript", expr_type, Subscript_fields);
    if (!Subscript_type) return 0;
    Starred_type.prototype.__class__ = make_type("Starred", expr_type, Starred_fields);
    if (!Starred_type) return 0;
    Name_type.prototype.__class__ = make_type("Name", expr_type, Name_fields);
    if (!Name_type) return 0;
    List_type.prototype.__class__ = make_type("List", expr_type, List_fields);
    if (!List_type) return 0;
    Tuple_type.prototype.__class__ = make_type("Tuple", expr_type, Tuple_fields);
    if (!Tuple_type) return 0;
    expr_context_type.prototype.__class__ = make_type("expr_context", AST_object, null);
    if (!expr_context_type) return 0;
    add_attributes(expr_context_type, null, 0);
    Load_type.prototype.__class__ = make_type("Load", expr_context_type, null);
    if (!Load_type) return 0;
    Load_singleton = new Load_type();
    if (!Load_singleton) return 0;
    Store_type.prototype.__class__ = make_type("Store", expr_context_type, null);
    if (!Store_type) return 0;
    Store_singleton = new Store_type();
    if (!Store_singleton) return 0;
    Del_type.prototype.__class__ = make_type("Del", expr_context_type, null);
    if (!Del_type) return 0;
    Del_singleton = new Del_type();
    if (!Del_singleton) return 0;
    AugLoad_type.prototype.__class__ = make_type("AugLoad", expr_context_type, null);
    if (!AugLoad_type) return 0;
    AugLoad_singleton = new AugLoad_type();
    if (!AugLoad_singleton) return 0;
    AugStore_type.prototype.__class__ = make_type("AugStore", expr_context_type, null);
    if (!AugStore_type) return 0;
    AugStore_singleton = new AugStore_type();
    if (!AugStore_singleton) return 0;
    Param_type.prototype.__class__ = make_type("Param", expr_context_type, null);
    if (!Param_type) return 0;
    Param_singleton = new Param_type();
    if (!Param_singleton) return 0;
    slice_type.prototype.__class__ = make_type("slice", AST_object, null);
    if (!slice_type) return 0;
    add_attributes(slice_type, null, 0);
    Slice_type.prototype.__class__ = make_type("Slice", slice_type, Slice_fields);
    if (!Slice_type) return 0;
    ExtSlice_type.prototype.__class__ = make_type("ExtSlice", slice_type, ExtSlice_fields);
    if (!ExtSlice_type) return 0;
    Index_type.prototype.__class__ = make_type("Index", slice_type, Index_fields);
    if (!Index_type) return 0;
    boolop_type.prototype.__class__ = make_type("boolop", AST_object, null);
    if (!boolop_type) return 0;
    add_attributes(boolop_type, null, 0);
    And_type.prototype.__class__ = make_type("And", boolop_type, null);
    if (!And_type) return 0;
    And_singleton = new And_type();
    if (!And_singleton) return 0;
    Or_type.prototype.__class__ = make_type("Or", boolop_type, null);
    if (!Or_type) return 0;
    Or_singleton = new Or_type();
    if (!Or_singleton) return 0;
    operator_type.prototype.__class__ = make_type("operator", AST_object, null);
    if (!operator_type) return 0;
    add_attributes(operator_type, null, 0);
    Add_type.prototype.__class__ = make_type("Add", operator_type, null);
    if (!Add_type) return 0;
    Add_singleton = new Add_type();
    if (!Add_singleton) return 0;
    Sub_type.prototype.__class__ = make_type("Sub", operator_type, null);
    if (!Sub_type) return 0;
    Sub_singleton = new Sub_type();
    if (!Sub_singleton) return 0;
    Mult_type.prototype.__class__ = make_type("Mult", operator_type, null);
    if (!Mult_type) return 0;
    Mult_singleton = new Mult_type();
    if (!Mult_singleton) return 0;
    MatMult_type.prototype.__class__ = make_type("MatMult", operator_type, null);
    if (!MatMult_type) return 0;
    MatMult_singleton = new MatMult_type();
    if (!MatMult_singleton) return 0;
    Div_type.prototype.__class__ = make_type("Div", operator_type, null);
    if (!Div_type) return 0;
    Div_singleton = new Div_type();
    if (!Div_singleton) return 0;
    Mod_type.prototype.__class__ = make_type("Mod", operator_type, null);
    if (!Mod_type) return 0;
    Mod_singleton = new Mod_type();
    if (!Mod_singleton) return 0;
    Pow_type.prototype.__class__ = make_type("Pow", operator_type, null);
    if (!Pow_type) return 0;
    Pow_singleton = new Pow_type();
    if (!Pow_singleton) return 0;
    LShift_type.prototype.__class__ = make_type("LShift", operator_type, null);
    if (!LShift_type) return 0;
    LShift_singleton = new LShift_type();
    if (!LShift_singleton) return 0;
    RShift_type.prototype.__class__ = make_type("RShift", operator_type, null);
    if (!RShift_type) return 0;
    RShift_singleton = new RShift_type();
    if (!RShift_singleton) return 0;
    BitOr_type.prototype.__class__ = make_type("BitOr", operator_type, null);
    if (!BitOr_type) return 0;
    BitOr_singleton = new BitOr_type();
    if (!BitOr_singleton) return 0;
    BitXor_type.prototype.__class__ = make_type("BitXor", operator_type, null);
    if (!BitXor_type) return 0;
    BitXor_singleton = new BitXor_type();
    if (!BitXor_singleton) return 0;
    BitAnd_type.prototype.__class__ = make_type("BitAnd", operator_type, null);
    if (!BitAnd_type) return 0;
    BitAnd_singleton = new BitAnd_type();
    if (!BitAnd_singleton) return 0;
    FloorDiv_type.prototype.__class__ = make_type("FloorDiv", operator_type, null);
    if (!FloorDiv_type) return 0;
    FloorDiv_singleton = new FloorDiv_type();
    if (!FloorDiv_singleton) return 0;
    unaryop_type.prototype.__class__ = make_type("unaryop", AST_object, null);
    if (!unaryop_type) return 0;
    add_attributes(unaryop_type, null, 0);
    Invert_type.prototype.__class__ = make_type("Invert", unaryop_type, null);
    if (!Invert_type) return 0;
    Invert_singleton = new Invert_type();
    if (!Invert_singleton) return 0;
    Not_type.prototype.__class__ = make_type("Not", unaryop_type, null);
    if (!Not_type) return 0;
    Not_singleton = new Not_type();
    if (!Not_singleton) return 0;
    UAdd_type.prototype.__class__ = make_type("UAdd", unaryop_type, null);
    if (!UAdd_type) return 0;
    UAdd_singleton = new UAdd_type();
    if (!UAdd_singleton) return 0;
    USub_type.prototype.__class__ = make_type("USub", unaryop_type, null);
    if (!USub_type) return 0;
    USub_singleton = new USub_type();
    if (!USub_singleton) return 0;
    cmpop_type.prototype.__class__ = make_type("cmpop", AST_object, null);
    if (!cmpop_type) return 0;
    add_attributes(cmpop_type, null, 0);
    Eq_type.prototype.__class__ = make_type("Eq", cmpop_type, null);
    if (!Eq_type) return 0;
    Eq_singleton = new Eq_type();
    if (!Eq_singleton) return 0;
    NotEq_type.prototype.__class__ = make_type("NotEq", cmpop_type, null);
    if (!NotEq_type) return 0;
    NotEq_singleton = new NotEq_type();
    if (!NotEq_singleton) return 0;
    Lt_type.prototype.__class__ = make_type("Lt", cmpop_type, null);
    if (!Lt_type) return 0;
    Lt_singleton = new Lt_type();
    if (!Lt_singleton) return 0;
    LtE_type.prototype.__class__ = make_type("LtE", cmpop_type, null);
    if (!LtE_type) return 0;
    LtE_singleton = new LtE_type();
    if (!LtE_singleton) return 0;
    Gt_type.prototype.__class__ = make_type("Gt", cmpop_type, null);
    if (!Gt_type) return 0;
    Gt_singleton = new Gt_type();
    if (!Gt_singleton) return 0;
    GtE_type.prototype.__class__ = make_type("GtE", cmpop_type, null);
    if (!GtE_type) return 0;
    GtE_singleton = new GtE_type();
    if (!GtE_singleton) return 0;
    Is_type.prototype.__class__ = make_type("Is", cmpop_type, null);
    if (!Is_type) return 0;
    Is_singleton = new Is_type();
    if (!Is_singleton) return 0;
    IsNot_type.prototype.__class__ = make_type("IsNot", cmpop_type, null);
    if (!IsNot_type) return 0;
    IsNot_singleton = new IsNot_type();
    if (!IsNot_singleton) return 0;
    In_type.prototype.__class__ = make_type("In", cmpop_type, null);
    if (!In_type) return 0;
    In_singleton = new In_type();
    if (!In_singleton) return 0;
    NotIn_type.prototype.__class__ = make_type("NotIn", cmpop_type, null);
    if (!NotIn_type) return 0;
    NotIn_singleton = new NotIn_type();
    if (!NotIn_singleton) return 0;
    comprehension_type.prototype.__class__ = make_type("comprehension", AST_object, comprehension_fields);
    if (!comprehension_type) return 0;
    add_attributes(comprehension_type, null, 0);
    excepthandler_type.prototype.__class__ = make_type("excepthandler", AST_object, null);
    if (!excepthandler_type) return 0;
    add_attributes(excepthandler_type, excepthandler_attributes, 2);
    ExceptHandler_type.prototype.__class__ = make_type("ExceptHandler", excepthandler_type, ExceptHandler_fields);
    if (!ExceptHandler_type) return 0;
    arguments_type.prototype.__class__ = make_type("arguments", AST_object, arguments_fields);
    if (!arguments_type) return 0;
    add_attributes(arguments_type, null, 0);
    arg_type.prototype.__class__ = make_type("arg", AST_object, arg_fields);
    if (!arg_type) return 0;
    add_attributes(arg_type, arg_attributes);
    keyword_type.prototype.__class__ = make_type("keyword", AST_object, keyword_fields);
    if (!keyword_type) return 0;
    add_attributes(keyword_type, null, 0);
    alias_type.prototype.__class__ = make_type("alias", AST_object, alias_fields);
    if (!alias_type) return 0;
    add_attributes(alias_type, null, 0);
    withitem_type.prototype.__class__ = make_type("withitem", AST_object, withitem_fields);
    if (!withitem_type) return 0;
    add_attributes(withitem_type, null, 0);
    initialized = 1;
    return 1;
};
init_types.initialized = 0;


var Module = function(body) {
    p.kind = Module_kind;
    p.v.Module.body = body;
    return p;
}

var Interactive = function(body) {
    p.kind = Interactive_kind;
    p.v.Interactive.body = body;
    return p;
}

var Expression = function(body) {
    if (!body) {
        throw new batavia.builtins.ValueError(
                        "field body is required for Expression");
    }
    p.kind = Expression_kind;
    p.v.Expression.body = body;
    return p;
}

var Suite = function(body) {
    p.kind = Suite_kind;
    p.v.Suite.body = body;
    return p;
}

var FunctionDef = function(name, args, body, decorator_list, returns, lineno, col_offset) {
    if (!name) {
        throw new batavia.builtins.ValueError(
                        "field name is required for FunctionDef");
    }
    if (!args) {
        throw new batavia.builtins.ValueError(
                        "field args is required for FunctionDef");
    }
    p.kind = FunctionDef_kind;
    p.v.FunctionDef.name = name;
    p.v.FunctionDef.args = args;
    p.v.FunctionDef.body = body;
    p.v.FunctionDef.decorator_list = decorator_list;
    p.v.FunctionDef.returns = returns;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var AsyncFunctionDef = function(name, args, body, decorator_list, returns, lineno, col_offset) {
    if (!name) {
        throw new batavia.builtins.ValueError(
                        "field name is required for AsyncFunctionDef");
    }
    if (!args) {
        throw new batavia.builtins.ValueError(
                        "field args is required for AsyncFunctionDef");
    }
    p.kind = AsyncFunctionDef_kind;
    p.v.AsyncFunctionDef.name = name;
    p.v.AsyncFunctionDef.args = args;
    p.v.AsyncFunctionDef.body = body;
    p.v.AsyncFunctionDef.decorator_list = decorator_list;
    p.v.AsyncFunctionDef.returns = returns;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var ClassDef = function(name, bases, keywords, body, decorator_list, lineno, col_offset) {
    if (!name) {
        throw new batavia.builtins.ValueError(
                        "field name is required for ClassDef");
    }
    p.kind = ClassDef_kind;
    p.v.ClassDef.name = name;
    p.v.ClassDef.bases = bases;
    p.v.ClassDef.keywords = keywords;
    p.v.ClassDef.body = body;
    p.v.ClassDef.decorator_list = decorator_list;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var Return = function(value, lineno, col_offset) {
    p.kind = Return_kind;
    p.v.Return.value = value;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var Delete = function(targets, lineno, col_offset) {
    p.kind = Delete_kind;
    p.v.Delete.targets = targets;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var Assign = function(targets, value, lineno, col_offset) {
    if (!value) {
        throw new batavia.builtins.ValueError(
                        "field value is required for Assign");
    }
    p.kind = Assign_kind;
    p.v.Assign.targets = targets;
    p.v.Assign.value = value;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var AugAssign = function(target, op, value, lineno, col_offset) {
    if (!target) {
        throw new batavia.builtins.ValueError(
                        "field target is required for AugAssign");
    }
    if (!op) {
        throw new batavia.builtins.ValueError(
                        "field op is required for AugAssign");
    }
    if (!value) {
        throw new batavia.builtins.ValueError(
                        "field value is required for AugAssign");
    }
    p.kind = AugAssign_kind;
    p.v.AugAssign.target = target;
    p.v.AugAssign.op = op;
    p.v.AugAssign.value = value;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var For = function(target, iter, body, orelse, lineno, col_offset) {
    if (!target) {
        throw new batavia.builtins.ValueError(
                        "field target is required for For");
    }
    if (!iter) {
        throw new batavia.builtins.ValueError(
                        "field iter is required for For");
    }
    p.kind = For_kind;
    p.v.For.target = target;
    p.v.For.iter = iter;
    p.v.For.body = body;
    p.v.For.orelse = orelse;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var AsyncFor = function(target, iter, body, orelse, lineno, col_offset) {
    if (!target) {
        throw new batavia.builtins.ValueError(
                        "field target is required for AsyncFor");
    }
    if (!iter) {
        throw new batavia.builtins.ValueError(
                        "field iter is required for AsyncFor");
    }
    p.kind = AsyncFor_kind;
    p.v.AsyncFor.target = target;
    p.v.AsyncFor.iter = iter;
    p.v.AsyncFor.body = body;
    p.v.AsyncFor.orelse = orelse;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var While = function(test, body, orelse, lineno, col_offset) {
    if (!test) {
        throw new batavia.builtins.ValueError(
                        "field test is required for While");
    }
    p.kind = While_kind;
    p.v.While.test = test;
    p.v.While.body = body;
    p.v.While.orelse = orelse;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var If = function(test, body, orelse, lineno, col_offset) {
    if (!test) {
        throw new batavia.builtins.ValueError(
                        "field test is required for If");
    }
    p.kind = If_kind;
    p.v.If.test = test;
    p.v.If.body = body;
    p.v.If.orelse = orelse;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var With = function(items, body, lineno, col_offset) {
    p.kind = With_kind;
    p.v.With.items = items;
    p.v.With.body = body;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var AsyncWith = function(items, body, lineno, col_offset) {
    p.kind = AsyncWith_kind;
    p.v.AsyncWith.items = items;
    p.v.AsyncWith.body = body;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var Raise = function(exc, cause, lineno, col_offset) {
    p.kind = Raise_kind;
    p.v.Raise.exc = exc;
    p.v.Raise.cause = cause;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var Try = function(body, handlers, orelse, finalbody, lineno, col_offset) {
    p.kind = Try_kind;
    p.v.Try.body = body;
    p.v.Try.handlers = handlers;
    p.v.Try.orelse = orelse;
    p.v.Try.finalbody = finalbody;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var Assert = function(test, msg, lineno, col_offset) {
    if (!test) {
        throw new batavia.builtins.ValueError(
                        "field test is required for Assert");
    }
    p.kind = Assert_kind;
    p.v.Assert.test = test;
    p.v.Assert.msg = msg;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var Import = function(names, lineno, col_offset) {
    p.kind = Import_kind;
    p.v.Import.names = names;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var ImportFrom = function(module, names, level, lineno, col_offset) {
    p.kind = ImportFrom_kind;
    p.v.ImportFrom.module = module;
    p.v.ImportFrom.names = names;
    p.v.ImportFrom.level = level;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var Global = function(names, lineno, col_offset) {
    p.kind = Global_kind;
    p.v.Global.names = names;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var Nonlocal = function(names, lineno, col_offset) {
    p.kind = Nonlocal_kind;
    p.v.Nonlocal.names = names;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var Expr = function(value, lineno, col_offset) {
    if (!value) {
        throw new batavia.builtins.ValueError(
                        "field value is required for Expr");
    }
    p.kind = Expr_kind;
    p.v.Expr.value = value;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var Pass = function(lineno, col_offset) {
    p.kind = Pass_kind;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var Break = function(lineno, col_offset) {
    p.kind = Break_kind;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var Continue = function(lineno, col_offset) {
    p.kind = Continue_kind;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var BoolOp = function(op, values, lineno, col_offset) {
    if (!op) {
        throw new batavia.builtins.ValueError(
                        "field op is required for BoolOp");
    }
    p.kind = BoolOp_kind;
    p.v.BoolOp.op = op;
    p.v.BoolOp.values = values;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var BinOp = function(left, op, right, lineno, col_offset) {
    if (!left) {
        throw new batavia.builtins.ValueError(
                        "field left is required for BinOp");
    }
    if (!op) {
        throw new batavia.builtins.ValueError(
                        "field op is required for BinOp");
    }
    if (!right) {
        throw new batavia.builtins.ValueError(
                        "field right is required for BinOp");
    }
    p.kind = BinOp_kind;
    p.v.BinOp.left = left;
    p.v.BinOp.op = op;
    p.v.BinOp.right = right;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var UnaryOp = function(op, operand, lineno, col_offset) {
    if (!op) {
        throw new batavia.builtins.ValueError(
                        "field op is required for UnaryOp");
    }
    if (!operand) {
        throw new batavia.builtins.ValueError(
                        "field operand is required for UnaryOp");
    }
    p.kind = UnaryOp_kind;
    p.v.UnaryOp.op = op;
    p.v.UnaryOp.operand = operand;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var Lambda = function(args, body, lineno, col_offset) {
    if (!args) {
        throw new batavia.builtins.ValueError(
                        "field args is required for Lambda");
    }
    if (!body) {
        throw new batavia.builtins.ValueError(
                        "field body is required for Lambda");
    }
    p.kind = Lambda_kind;
    p.v.Lambda.args = args;
    p.v.Lambda.body = body;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var IfExp = function(test, body, orelse, lineno, col_offset) {
    if (!test) {
        throw new batavia.builtins.ValueError(
                        "field test is required for IfExp");
    }
    if (!body) {
        throw new batavia.builtins.ValueError(
                        "field body is required for IfExp");
    }
    if (!orelse) {
        throw new batavia.builtins.ValueError(
                        "field orelse is required for IfExp");
    }
    p.kind = IfExp_kind;
    p.v.IfExp.test = test;
    p.v.IfExp.body = body;
    p.v.IfExp.orelse = orelse;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var Dict = function(keys, values, lineno, col_offset) {
    p.kind = Dict_kind;
    p.v.Dict.keys = keys;
    p.v.Dict.values = values;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var Set = function(elts, lineno, col_offset) {
    p.kind = Set_kind;
    p.v.Set.elts = elts;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var ListComp = function(elt, generators, lineno, col_offset) {
    if (!elt) {
        throw new batavia.builtins.ValueError(
                        "field elt is required for ListComp");
    }
    p.kind = ListComp_kind;
    p.v.ListComp.elt = elt;
    p.v.ListComp.generators = generators;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var SetComp = function(elt, generators, lineno, col_offset) {
    if (!elt) {
        throw new batavia.builtins.ValueError(
                        "field elt is required for SetComp");
    }
    p.kind = SetComp_kind;
    p.v.SetComp.elt = elt;
    p.v.SetComp.generators = generators;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var DictComp = function(key, value, generators, lineno, col_offset) {
    if (!key) {
        throw new batavia.builtins.ValueError(
                        "field key is required for DictComp");
    }
    if (!value) {
        throw new batavia.builtins.ValueError(
                        "field value is required for DictComp");
    }
    p.kind = DictComp_kind;
    p.v.DictComp.key = key;
    p.v.DictComp.value = value;
    p.v.DictComp.generators = generators;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var GeneratorExp = function(elt, generators, lineno, col_offset) {
    if (!elt) {
        throw new batavia.builtins.ValueError(
                        "field elt is required for GeneratorExp");
    }
    p.kind = GeneratorExp_kind;
    p.v.GeneratorExp.elt = elt;
    p.v.GeneratorExp.generators = generators;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var Await = function(value, lineno, col_offset) {
    if (!value) {
        throw new batavia.builtins.ValueError(
                        "field value is required for Await");
    }
    p.kind = Await_kind;
    p.v.Await.value = value;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var Yield = function(value, lineno, col_offset) {
    p.kind = Yield_kind;
    p.v.Yield.value = value;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var YieldFrom = function(value, lineno, col_offset) {
    if (!value) {
        throw new batavia.builtins.ValueError(
                        "field value is required for YieldFrom");
    }
    p.kind = YieldFrom_kind;
    p.v.YieldFrom.value = value;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var Compare = function(left, ops, comparators, lineno, col_offset) {
    if (!left) {
        throw new batavia.builtins.ValueError(
                        "field left is required for Compare");
    }
    p.kind = Compare_kind;
    p.v.Compare.left = left;
    p.v.Compare.ops = ops;
    p.v.Compare.comparators = comparators;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var Call = function(func, args, keywords, lineno, col_offset) {
    if (!func) {
        throw new batavia.builtins.ValueError(
                        "field func is required for Call");
    }
    p.kind = Call_kind;
    p.v.Call.func = func;
    p.v.Call.args = args;
    p.v.Call.keywords = keywords;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var Num = function(n, lineno, col_offset) {
    if (!n) {
        throw new batavia.builtins.ValueError(
                        "field n is required for Num");
    }
    p.kind = Num_kind;
    p.v.Num.n = n;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var Str = function(s, lineno, col_offset) {
    if (!s) {
        throw new batavia.builtins.ValueError(
                        "field s is required for Str");
    }
    p.kind = Str_kind;
    p.v.Str.s = s;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var FormattedValue = function(value, conversion, format_spec, lineno, col_offset) {
    if (!value) {
        throw new batavia.builtins.ValueError(
                        "field value is required for FormattedValue");
    }
    p.kind = FormattedValue_kind;
    p.v.FormattedValue.value = value;
    p.v.FormattedValue.conversion = conversion;
    p.v.FormattedValue.format_spec = format_spec;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var JoinedStr = function(values, lineno, col_offset) {
    p.kind = JoinedStr_kind;
    p.v.JoinedStr.values = values;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var Bytes = function(s, lineno, col_offset) {
    if (!s) {
        throw new batavia.builtins.ValueError(
                        "field s is required for Bytes");
    }
    p.kind = Bytes_kind;
    p.v.Bytes.s = s;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var NameConstant = function(value, lineno, col_offset) {
    if (!value) {
        throw new batavia.builtins.ValueError(
                        "field value is required for NameConstant");
    }
    p.kind = NameConstant_kind;
    p.v.NameConstant.value = value;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var Ellipsis = function(lineno, col_offset) {
    p.kind = Ellipsis_kind;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var Constant = function(value, lineno, col_offset) {
    if (!value) {
        throw new batavia.builtins.ValueError(
                        "field value is required for Constant");
    }
    p.kind = Constant_kind;
    p.v.Constant.value = value;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var Attribute = function(value, attr, ctx, lineno, col_offset) {
    if (!value) {
        throw new batavia.builtins.ValueError(
                        "field value is required for Attribute");
    }
    if (!attr) {
        throw new batavia.builtins.ValueError(
                        "field attr is required for Attribute");
    }
    if (!ctx) {
        throw new batavia.builtins.ValueError(
                        "field ctx is required for Attribute");
    }
    p.kind = Attribute_kind;
    p.v.Attribute.value = value;
    p.v.Attribute.attr = attr;
    p.v.Attribute.ctx = ctx;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var Subscript = function(value, slice, ctx, lineno, col_offset) {
    if (!value) {
        throw new batavia.builtins.ValueError(
                        "field value is required for Subscript");
    }
    if (!slice) {
        throw new batavia.builtins.ValueError(
                        "field slice is required for Subscript");
    }
    if (!ctx) {
        throw new batavia.builtins.ValueError(
                        "field ctx is required for Subscript");
    }
    p.kind = Subscript_kind;
    p.v.Subscript.value = value;
    p.v.Subscript.slice = slice;
    p.v.Subscript.ctx = ctx;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var Starred = function(value, ctx, lineno, col_offset) {
    if (!value) {
        throw new batavia.builtins.ValueError(
                        "field value is required for Starred");
    }
    if (!ctx) {
        throw new batavia.builtins.ValueError(
                        "field ctx is required for Starred");
    }
    p.kind = Starred_kind;
    p.v.Starred.value = value;
    p.v.Starred.ctx = ctx;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var Name = function(id, ctx, lineno, col_offset) {
    if (!id) {
        throw new batavia.builtins.ValueError(
                        "field id is required for Name");
    }
    if (!ctx) {
        throw new batavia.builtins.ValueError(
                        "field ctx is required for Name");
    }
    p.kind = Name_kind;
    p.v.Name.id = id;
    p.v.Name.ctx = ctx;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var List = function(elts, ctx, lineno, col_offset) {
    if (!ctx) {
        throw new batavia.builtins.ValueError(
                        "field ctx is required for List");
    }
    p.kind = List_kind;
    p.v.List.elts = elts;
    p.v.List.ctx = ctx;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var Tuple = function(elts, ctx, lineno, col_offset) {
    if (!ctx) {
        throw new batavia.builtins.ValueError(
                        "field ctx is required for Tuple");
    }
    p.kind = Tuple_kind;
    p.v.Tuple.elts = elts;
    p.v.Tuple.ctx = ctx;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var Slice = function(lower, upper, step) {
    p.kind = Slice_kind;
    p.v.Slice.lower = lower;
    p.v.Slice.upper = upper;
    p.v.Slice.step = step;
    return p;
}

var ExtSlice = function(dims) {
    p.kind = ExtSlice_kind;
    p.v.ExtSlice.dims = dims;
    return p;
}

var Index = function(value) {
    if (!value) {
        throw new batavia.builtins.ValueError(
                        "field value is required for Index");
    }
    p.kind = Index_kind;
    p.v.Index.value = value;
    return p;
}

var comprehension = function(target, iter, ifs) {
    if (!target) {
        throw new batavia.builtins.ValueError(
                        "field target is required for comprehension");
    }
    if (!iter) {
        throw new batavia.builtins.ValueError(
                        "field iter is required for comprehension");
    }
    p.target = target;
    p.iter = iter;
    p.ifs = ifs;
    return p;
}

var ExceptHandler = function(type, name, body, lineno, col_offset) {
    p.kind = ExceptHandler_kind;
    p.v.ExceptHandler.type = type;
    p.v.ExceptHandler.name = name;
    p.v.ExceptHandler.body = body;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var arguments = function(args, vararg, kwonlyargs, kw_defaults, kwarg, defaults) {
    p.args = args;
    p.vararg = vararg;
    p.kwonlyargs = kwonlyargs;
    p.kw_defaults = kw_defaults;
    p.kwarg = kwarg;
    p.defaults = defaults;
    return p;
}

var arg = function(arg, annotation, lineno, col_offset) {
    if (!arg) {
        throw new batavia.builtins.ValueError(
                        "field arg is required for arg");
    }
    p.arg = arg;
    p.annotation = annotation;
    p.lineno = lineno;
    p.col_offset = col_offset;
    return p;
}

var keyword = function(arg, value) {
    if (!value) {
        throw new batavia.builtins.ValueError(
                        "field value is required for keyword");
    }
    p.arg = arg;
    p.value = value;
    return p;
}

var alias = function(name, asname) {
    if (!name) {
        throw new batavia.builtins.ValueError(
                        "field name is required for alias");
    }
    p.name = name;
    p.asname = asname;
    return p;
}

var withitem = function(context_expr, optional_vars) {
    if (!context_expr) {
        throw new batavia.builtins.ValueError(
                        "field context_expr is required for withitem");
    }
    p.context_expr = context_expr;
    p.optional_vars = optional_vars;
    return p;
}


var ast2obj_mod = function(_o) {
    var o = _o;
    var result = null;
    var value = null;
    if (!o) {
        return null;
    }

    switch (o.kind) {
    case Module_kind:
        result = PyType_GenericNew(Module_type, null, null);
        if (!result) return null;
        value = ast2obj_list(o.v.Module.body, ast2obj_stmt);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_body, value) == -1)
            return null;
        break;
    case Interactive_kind:
        result = PyType_GenericNew(Interactive_type, null, null);
        if (!result) return null;
        value = ast2obj_list(o.v.Interactive.body, ast2obj_stmt);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_body, value) == -1)
            return null;
        break;
    case Expression_kind:
        result = PyType_GenericNew(Expression_type, null, null);
        if (!result) return null;
        value = ast2obj_expr(o.v.Expression.body);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_body, value) == -1)
            return null;
        break;
    case Suite_kind:
        result = PyType_GenericNew(Suite_type, null, null);
        if (!result) return null;
        value = ast2obj_list(o.v.Suite.body, ast2obj_stmt);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_body, value) == -1)
            return null;
        break;
    }
    return result;
};

var ast2obj_stmt = function(_o) {
    var o = _o;
    var result = null;
    var value = null;
    if (!o) {
        return null;
    }

    switch (o.kind) {
    case FunctionDef_kind:
        result = PyType_GenericNew(FunctionDef_type, null, null);
        if (!result) return null;
        value = ast2obj_identifier(o.v.FunctionDef.name);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_name, value) == -1)
            return null;
        value = ast2obj_arguments(o.v.FunctionDef.args);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_args, value) == -1)
            return null;
        value = ast2obj_list(o.v.FunctionDef.body, ast2obj_stmt);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_body, value) == -1)
            return null;
        value = ast2obj_list(o.v.FunctionDef.decorator_list, ast2obj_expr);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_decorator_list, value) == -1)
            return null;
        value = ast2obj_expr(o.v.FunctionDef.returns);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_returns, value) == -1)
            return null;
        break;
    case AsyncFunctionDef_kind:
        result = PyType_GenericNew(AsyncFunctionDef_type, null, null);
        if (!result) return null;
        value = ast2obj_identifier(o.v.AsyncFunctionDef.name);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_name, value) == -1)
            return null;
        value = ast2obj_arguments(o.v.AsyncFunctionDef.args);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_args, value) == -1)
            return null;
        value = ast2obj_list(o.v.AsyncFunctionDef.body, ast2obj_stmt);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_body, value) == -1)
            return null;
        value = ast2obj_list(o.v.AsyncFunctionDef.decorator_list, ast2obj_expr);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_decorator_list, value) == -1)
            return null;
        value = ast2obj_expr(o.v.AsyncFunctionDef.returns);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_returns, value) == -1)
            return null;
        break;
    case ClassDef_kind:
        result = PyType_GenericNew(ClassDef_type, null, null);
        if (!result) return null;
        value = ast2obj_identifier(o.v.ClassDef.name);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_name, value) == -1)
            return null;
        value = ast2obj_list(o.v.ClassDef.bases, ast2obj_expr);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_bases, value) == -1)
            return null;
        value = ast2obj_list(o.v.ClassDef.keywords, ast2obj_keyword);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_keywords, value) == -1)
            return null;
        value = ast2obj_list(o.v.ClassDef.body, ast2obj_stmt);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_body, value) == -1)
            return null;
        value = ast2obj_list(o.v.ClassDef.decorator_list, ast2obj_expr);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_decorator_list, value) == -1)
            return null;
        break;
    case Return_kind:
        result = PyType_GenericNew(Return_type, null, null);
        if (!result) return null;
        value = ast2obj_expr(o.v.Return.value);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_value, value) == -1)
            return null;
        break;
    case Delete_kind:
        result = PyType_GenericNew(Delete_type, null, null);
        if (!result) return null;
        value = ast2obj_list(o.v.Delete.targets, ast2obj_expr);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_targets, value) == -1)
            return null;
        break;
    case Assign_kind:
        result = PyType_GenericNew(Assign_type, null, null);
        if (!result) return null;
        value = ast2obj_list(o.v.Assign.targets, ast2obj_expr);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_targets, value) == -1)
            return null;
        value = ast2obj_expr(o.v.Assign.value);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_value, value) == -1)
            return null;
        break;
    case AugAssign_kind:
        result = PyType_GenericNew(AugAssign_type, null, null);
        if (!result) return null;
        value = ast2obj_expr(o.v.AugAssign.target);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_target, value) == -1)
            return null;
        value = ast2obj_operator(o.v.AugAssign.op);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_op, value) == -1)
            return null;
        value = ast2obj_expr(o.v.AugAssign.value);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_value, value) == -1)
            return null;
        break;
    case For_kind:
        result = PyType_GenericNew(For_type, null, null);
        if (!result) return null;
        value = ast2obj_expr(o.v.For.target);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_target, value) == -1)
            return null;
        value = ast2obj_expr(o.v.For.iter);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_iter, value) == -1)
            return null;
        value = ast2obj_list(o.v.For.body, ast2obj_stmt);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_body, value) == -1)
            return null;
        value = ast2obj_list(o.v.For.orelse, ast2obj_stmt);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_orelse, value) == -1)
            return null;
        break;
    case AsyncFor_kind:
        result = PyType_GenericNew(AsyncFor_type, null, null);
        if (!result) return null;
        value = ast2obj_expr(o.v.AsyncFor.target);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_target, value) == -1)
            return null;
        value = ast2obj_expr(o.v.AsyncFor.iter);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_iter, value) == -1)
            return null;
        value = ast2obj_list(o.v.AsyncFor.body, ast2obj_stmt);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_body, value) == -1)
            return null;
        value = ast2obj_list(o.v.AsyncFor.orelse, ast2obj_stmt);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_orelse, value) == -1)
            return null;
        break;
    case While_kind:
        result = PyType_GenericNew(While_type, null, null);
        if (!result) return null;
        value = ast2obj_expr(o.v.While.test);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_test, value) == -1)
            return null;
        value = ast2obj_list(o.v.While.body, ast2obj_stmt);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_body, value) == -1)
            return null;
        value = ast2obj_list(o.v.While.orelse, ast2obj_stmt);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_orelse, value) == -1)
            return null;
        break;
    case If_kind:
        result = PyType_GenericNew(If_type, null, null);
        if (!result) return null;
        value = ast2obj_expr(o.v.If.test);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_test, value) == -1)
            return null;
        value = ast2obj_list(o.v.If.body, ast2obj_stmt);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_body, value) == -1)
            return null;
        value = ast2obj_list(o.v.If.orelse, ast2obj_stmt);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_orelse, value) == -1)
            return null;
        break;
    case With_kind:
        result = PyType_GenericNew(With_type, null, null);
        if (!result) return null;
        value = ast2obj_list(o.v.With.items, ast2obj_withitem);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_items, value) == -1)
            return null;
        value = ast2obj_list(o.v.With.body, ast2obj_stmt);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_body, value) == -1)
            return null;
        break;
    case AsyncWith_kind:
        result = PyType_GenericNew(AsyncWith_type, null, null);
        if (!result) return null;
        value = ast2obj_list(o.v.AsyncWith.items, ast2obj_withitem);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_items, value) == -1)
            return null;
        value = ast2obj_list(o.v.AsyncWith.body, ast2obj_stmt);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_body, value) == -1)
            return null;
        break;
    case Raise_kind:
        result = PyType_GenericNew(Raise_type, null, null);
        if (!result) return null;
        value = ast2obj_expr(o.v.Raise.exc);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_exc, value) == -1)
            return null;
        value = ast2obj_expr(o.v.Raise.cause);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_cause, value) == -1)
            return null;
        break;
    case Try_kind:
        result = PyType_GenericNew(Try_type, null, null);
        if (!result) return null;
        value = ast2obj_list(o.v.Try.body, ast2obj_stmt);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_body, value) == -1)
            return null;
        value = ast2obj_list(o.v.Try.handlers, ast2obj_excepthandler);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_handlers, value) == -1)
            return null;
        value = ast2obj_list(o.v.Try.orelse, ast2obj_stmt);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_orelse, value) == -1)
            return null;
        value = ast2obj_list(o.v.Try.finalbody, ast2obj_stmt);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_finalbody, value) == -1)
            return null;
        break;
    case Assert_kind:
        result = PyType_GenericNew(Assert_type, null, null);
        if (!result) return null;
        value = ast2obj_expr(o.v.Assert.test);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_test, value) == -1)
            return null;
        value = ast2obj_expr(o.v.Assert.msg);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_msg, value) == -1)
            return null;
        break;
    case Import_kind:
        result = PyType_GenericNew(Import_type, null, null);
        if (!result) return null;
        value = ast2obj_list(o.v.Import.names, ast2obj_alias);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_names, value) == -1)
            return null;
        break;
    case ImportFrom_kind:
        result = PyType_GenericNew(ImportFrom_type, null, null);
        if (!result) return null;
        value = ast2obj_identifier(o.v.ImportFrom.module);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_module, value) == -1)
            return null;
        value = ast2obj_list(o.v.ImportFrom.names, ast2obj_alias);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_names, value) == -1)
            return null;
        value = ast2obj_int(o.v.ImportFrom.level);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_level, value) == -1)
            return null;
        break;
    case Global_kind:
        result = PyType_GenericNew(Global_type, null, null);
        if (!result) return null;
        value = ast2obj_list(o.v.Global.names, ast2obj_identifier);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_names, value) == -1)
            return null;
        break;
    case Nonlocal_kind:
        result = PyType_GenericNew(Nonlocal_type, null, null);
        if (!result) return null;
        value = ast2obj_list(o.v.Nonlocal.names, ast2obj_identifier);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_names, value) == -1)
            return null;
        break;
    case Expr_kind:
        result = PyType_GenericNew(Expr_type, null, null);
        if (!result) return null;
        value = ast2obj_expr(o.v.Expr.value);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_value, value) == -1)
            return null;
        break;
    case Pass_kind:
        result = PyType_GenericNew(Pass_type, null, null);
        if (!result) return null;
        break;
    case Break_kind:
        result = PyType_GenericNew(Break_type, null, null);
        if (!result) return null;
        break;
    case Continue_kind:
        result = PyType_GenericNew(Continue_type, null, null);
        if (!result) return null;
        break;
    }
    value = ast2obj_int(o.lineno);
    if (!value) return null;
    if (_PyObject_SetAttrId(result, PyId_lineno, value) < 0)
        return null;
    value = ast2obj_int(o.col_offset);
    if (!value) return null;
    if (_PyObject_SetAttrId(result, PyId_col_offset, value) < 0)
        return null;
    return result;
};

var ast2obj_expr = function(_o) {
    var o = _o;
    var result = null;
    var value = null;
    if (!o) {
        return null;
    }

    switch (o.kind) {
    case BoolOp_kind:
        result = PyType_GenericNew(BoolOp_type, null, null);
        if (!result) return null;
        value = ast2obj_boolop(o.v.BoolOp.op);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_op, value) == -1)
            return null;
        value = ast2obj_list(o.v.BoolOp.values, ast2obj_expr);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_values, value) == -1)
            return null;
        break;
    case BinOp_kind:
        result = PyType_GenericNew(BinOp_type, null, null);
        if (!result) return null;
        value = ast2obj_expr(o.v.BinOp.left);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_left, value) == -1)
            return null;
        value = ast2obj_operator(o.v.BinOp.op);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_op, value) == -1)
            return null;
        value = ast2obj_expr(o.v.BinOp.right);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_right, value) == -1)
            return null;
        break;
    case UnaryOp_kind:
        result = PyType_GenericNew(UnaryOp_type, null, null);
        if (!result) return null;
        value = ast2obj_unaryop(o.v.UnaryOp.op);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_op, value) == -1)
            return null;
        value = ast2obj_expr(o.v.UnaryOp.operand);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_operand, value) == -1)
            return null;
        break;
    case Lambda_kind:
        result = PyType_GenericNew(Lambda_type, null, null);
        if (!result) return null;
        value = ast2obj_arguments(o.v.Lambda.args);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_args, value) == -1)
            return null;
        value = ast2obj_expr(o.v.Lambda.body);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_body, value) == -1)
            return null;
        break;
    case IfExp_kind:
        result = PyType_GenericNew(IfExp_type, null, null);
        if (!result) return null;
        value = ast2obj_expr(o.v.IfExp.test);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_test, value) == -1)
            return null;
        value = ast2obj_expr(o.v.IfExp.body);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_body, value) == -1)
            return null;
        value = ast2obj_expr(o.v.IfExp.orelse);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_orelse, value) == -1)
            return null;
        break;
    case Dict_kind:
        result = PyType_GenericNew(Dict_type, null, null);
        if (!result) return null;
        value = ast2obj_list(o.v.Dict.keys, ast2obj_expr);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_keys, value) == -1)
            return null;
        value = ast2obj_list(o.v.Dict.values, ast2obj_expr);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_values, value) == -1)
            return null;
        break;
    case Set_kind:
        result = PyType_GenericNew(Set_type, null, null);
        if (!result) return null;
        value = ast2obj_list(o.v.Set.elts, ast2obj_expr);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_elts, value) == -1)
            return null;
        break;
    case ListComp_kind:
        result = PyType_GenericNew(ListComp_type, null, null);
        if (!result) return null;
        value = ast2obj_expr(o.v.ListComp.elt);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_elt, value) == -1)
            return null;
        value = ast2obj_list(o.v.ListComp.generators, ast2obj_comprehension);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_generators, value) == -1)
            return null;
        break;
    case SetComp_kind:
        result = PyType_GenericNew(SetComp_type, null, null);
        if (!result) return null;
        value = ast2obj_expr(o.v.SetComp.elt);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_elt, value) == -1)
            return null;
        value = ast2obj_list(o.v.SetComp.generators, ast2obj_comprehension);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_generators, value) == -1)
            return null;
        break;
    case DictComp_kind:
        result = PyType_GenericNew(DictComp_type, null, null);
        if (!result) return null;
        value = ast2obj_expr(o.v.DictComp.key);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_key, value) == -1)
            return null;
        value = ast2obj_expr(o.v.DictComp.value);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_value, value) == -1)
            return null;
        value = ast2obj_list(o.v.DictComp.generators, ast2obj_comprehension);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_generators, value) == -1)
            return null;
        break;
    case GeneratorExp_kind:
        result = PyType_GenericNew(GeneratorExp_type, null, null);
        if (!result) return null;
        value = ast2obj_expr(o.v.GeneratorExp.elt);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_elt, value) == -1)
            return null;
        value = ast2obj_list(o.v.GeneratorExp.generators, ast2obj_comprehension);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_generators, value) == -1)
            return null;
        break;
    case Await_kind:
        result = PyType_GenericNew(Await_type, null, null);
        if (!result) return null;
        value = ast2obj_expr(o.v.Await.value);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_value, value) == -1)
            return null;
        break;
    case Yield_kind:
        result = PyType_GenericNew(Yield_type, null, null);
        if (!result) return null;
        value = ast2obj_expr(o.v.Yield.value);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_value, value) == -1)
            return null;
        break;
    case YieldFrom_kind:
        result = PyType_GenericNew(YieldFrom_type, null, null);
        if (!result) return null;
        value = ast2obj_expr(o.v.YieldFrom.value);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_value, value) == -1)
            return null;
        break;
    case Compare_kind:
        result = PyType_GenericNew(Compare_type, null, null);
        if (!result) return null;
        value = ast2obj_expr(o.v.Compare.left);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_left, value) == -1)
            return null;
        {
            var i; var n = asdl_seq_LEN(o.v.Compare.ops);
            value = PyList_New(n);
            if (!value) return null;
            for(i = 0; i < n; i++)
                PyList_SET_ITEM(value, i, ast2obj_cmpop(asdl_seq_GET(o.v.Compare.ops, i)));
        }
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_ops, value) == -1)
            return null;
        value = ast2obj_list(o.v.Compare.comparators, ast2obj_expr);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_comparators, value) == -1)
            return null;
        break;
    case Call_kind:
        result = PyType_GenericNew(Call_type, null, null);
        if (!result) return null;
        value = ast2obj_expr(o.v.Call.func);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_func, value) == -1)
            return null;
        value = ast2obj_list(o.v.Call.args, ast2obj_expr);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_args, value) == -1)
            return null;
        value = ast2obj_list(o.v.Call.keywords, ast2obj_keyword);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_keywords, value) == -1)
            return null;
        break;
    case Num_kind:
        result = PyType_GenericNew(Num_type, null, null);
        if (!result) return null;
        value = ast2obj_object(o.v.Num.n);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_n, value) == -1)
            return null;
        break;
    case Str_kind:
        result = PyType_GenericNew(Str_type, null, null);
        if (!result) return null;
        value = ast2obj_string(o.v.Str.s);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_s, value) == -1)
            return null;
        break;
    case FormattedValue_kind:
        result = PyType_GenericNew(FormattedValue_type, null, null);
        if (!result) return null;
        value = ast2obj_expr(o.v.FormattedValue.value);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_value, value) == -1)
            return null;
        value = ast2obj_int(o.v.FormattedValue.conversion);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_conversion, value) == -1)
            return null;
        value = ast2obj_expr(o.v.FormattedValue.format_spec);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_format_spec, value) == -1)
            return null;
        break;
    case JoinedStr_kind:
        result = PyType_GenericNew(JoinedStr_type, null, null);
        if (!result) return null;
        value = ast2obj_list(o.v.JoinedStr.values, ast2obj_expr);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_values, value) == -1)
            return null;
        break;
    case Bytes_kind:
        result = PyType_GenericNew(Bytes_type, null, null);
        if (!result) return null;
        value = ast2obj_bytes(o.v.Bytes.s);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_s, value) == -1)
            return null;
        break;
    case NameConstant_kind:
        result = PyType_GenericNew(NameConstant_type, null, null);
        if (!result) return null;
        value = ast2obj_singleton(o.v.NameConstant.value);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_value, value) == -1)
            return null;
        break;
    case Ellipsis_kind:
        result = PyType_GenericNew(Ellipsis_type, null, null);
        if (!result) return null;
        break;
    case Constant_kind:
        result = PyType_GenericNew(Constant_type, null, null);
        if (!result) return null;
        value = ast2obj_constant(o.v.Constant.value);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_value, value) == -1)
            return null;
        break;
    case Attribute_kind:
        result = PyType_GenericNew(Attribute_type, null, null);
        if (!result) return null;
        value = ast2obj_expr(o.v.Attribute.value);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_value, value) == -1)
            return null;
        value = ast2obj_identifier(o.v.Attribute.attr);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_attr, value) == -1)
            return null;
        value = ast2obj_expr_context(o.v.Attribute.ctx);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_ctx, value) == -1)
            return null;
        break;
    case Subscript_kind:
        result = PyType_GenericNew(Subscript_type, null, null);
        if (!result) return null;
        value = ast2obj_expr(o.v.Subscript.value);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_value, value) == -1)
            return null;
        value = ast2obj_slice(o.v.Subscript.slice);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_slice, value) == -1)
            return null;
        value = ast2obj_expr_context(o.v.Subscript.ctx);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_ctx, value) == -1)
            return null;
        break;
    case Starred_kind:
        result = PyType_GenericNew(Starred_type, null, null);
        if (!result) return null;
        value = ast2obj_expr(o.v.Starred.value);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_value, value) == -1)
            return null;
        value = ast2obj_expr_context(o.v.Starred.ctx);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_ctx, value) == -1)
            return null;
        break;
    case Name_kind:
        result = PyType_GenericNew(Name_type, null, null);
        if (!result) return null;
        value = ast2obj_identifier(o.v.Name.id);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_id, value) == -1)
            return null;
        value = ast2obj_expr_context(o.v.Name.ctx);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_ctx, value) == -1)
            return null;
        break;
    case List_kind:
        result = PyType_GenericNew(List_type, null, null);
        if (!result) return null;
        value = ast2obj_list(o.v.List.elts, ast2obj_expr);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_elts, value) == -1)
            return null;
        value = ast2obj_expr_context(o.v.List.ctx);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_ctx, value) == -1)
            return null;
        break;
    case Tuple_kind:
        result = PyType_GenericNew(Tuple_type, null, null);
        if (!result) return null;
        value = ast2obj_list(o.v.Tuple.elts, ast2obj_expr);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_elts, value) == -1)
            return null;
        value = ast2obj_expr_context(o.v.Tuple.ctx);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_ctx, value) == -1)
            return null;
        break;
    }
    value = ast2obj_int(o.lineno);
    if (!value) return null;
    if (_PyObject_SetAttrId(result, PyId_lineno, value) < 0)
        return null;
    value = ast2obj_int(o.col_offset);
    if (!value) return null;
    if (_PyObject_SetAttrId(result, PyId_col_offset, value) < 0)
        return null;
    return result;
};

var ast2obj_expr_context = function(o) {
    switch(o) {
        case Load:
            return Load_singleton;
        case Store:
            return Store_singleton;
        case Del:
            return Del_singleton;
        case AugLoad:
            return AugLoad_singleton;
        case AugStore:
            return AugStore_singleton;
        case Param:
            return Param_singleton;
        default:
            /* should never happen, but just in case ... */
            PyErr_Format(PyExc_SystemError, "unknown expr_context found");
            return null;
    }
};
var ast2obj_slice = function(_o) {
    var o = _o;
    var result = null;
    var value = null;
    if (!o) {
        return null;
    }

    switch (o.kind) {
    case Slice_kind:
        result = PyType_GenericNew(Slice_type, null, null);
        if (!result) return null;
        value = ast2obj_expr(o.v.Slice.lower);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_lower, value) == -1)
            return null;
        value = ast2obj_expr(o.v.Slice.upper);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_upper, value) == -1)
            return null;
        value = ast2obj_expr(o.v.Slice.step);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_step, value) == -1)
            return null;
        break;
    case ExtSlice_kind:
        result = PyType_GenericNew(ExtSlice_type, null, null);
        if (!result) return null;
        value = ast2obj_list(o.v.ExtSlice.dims, ast2obj_slice);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_dims, value) == -1)
            return null;
        break;
    case Index_kind:
        result = PyType_GenericNew(Index_type, null, null);
        if (!result) return null;
        value = ast2obj_expr(o.v.Index.value);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_value, value) == -1)
            return null;
        break;
    }
    return result;
};

var ast2obj_boolop = function(o) {
    switch(o) {
        case And:
            return And_singleton;
        case Or:
            return Or_singleton;
        default:
            /* should never happen, but just in case ... */
            PyErr_Format(PyExc_SystemError, "unknown boolop found");
            return null;
    }
};
var ast2obj_operator = function(o) {
    switch(o) {
        case Add:
            return Add_singleton;
        case Sub:
            return Sub_singleton;
        case Mult:
            return Mult_singleton;
        case MatMult:
            return MatMult_singleton;
        case Div:
            return Div_singleton;
        case Mod:
            return Mod_singleton;
        case Pow:
            return Pow_singleton;
        case LShift:
            return LShift_singleton;
        case RShift:
            return RShift_singleton;
        case BitOr:
            return BitOr_singleton;
        case BitXor:
            return BitXor_singleton;
        case BitAnd:
            return BitAnd_singleton;
        case FloorDiv:
            return FloorDiv_singleton;
        default:
            /* should never happen, but just in case ... */
            PyErr_Format(PyExc_SystemError, "unknown operator found");
            return null;
    }
};
var ast2obj_unaryop = function(o) {
    switch(o) {
        case Invert:
            return Invert_singleton;
        case Not:
            return Not_singleton;
        case UAdd:
            return UAdd_singleton;
        case USub:
            return USub_singleton;
        default:
            /* should never happen, but just in case ... */
            PyErr_Format(PyExc_SystemError, "unknown unaryop found");
            return null;
    }
};
var ast2obj_cmpop = function(o) {
    switch(o) {
        case Eq:
            return Eq_singleton;
        case NotEq:
            return NotEq_singleton;
        case Lt:
            return Lt_singleton;
        case LtE:
            return LtE_singleton;
        case Gt:
            return Gt_singleton;
        case GtE:
            return GtE_singleton;
        case Is:
            return Is_singleton;
        case IsNot:
            return IsNot_singleton;
        case In:
            return In_singleton;
        case NotIn:
            return NotIn_singleton;
        default:
            /* should never happen, but just in case ... */
            PyErr_Format(PyExc_SystemError, "unknown cmpop found");
            return null;
    }
};
var ast2obj_comprehension = function(_o) {
    var o = _o;
    var result = null;
    var value = null;
    if (!o) {
        return null;
    }

    result = PyType_GenericNew(comprehension_type, null, null);
    if (!result) return null;
    value = ast2obj_expr(o.target);
    if (!value) return null;
    if (_PyObject_SetAttrId(result, PyId_target, value) == -1)
        return null;
    value = ast2obj_expr(o.iter);
    if (!value) return null;
    if (_PyObject_SetAttrId(result, PyId_iter, value) == -1)
        return null;
    value = ast2obj_list(o.ifs, ast2obj_expr);
    if (!value) return null;
    if (_PyObject_SetAttrId(result, PyId_ifs, value) == -1)
        return null;
    return result;
};

var ast2obj_excepthandler = function(_o) {
    var o = _o;
    var result = null;
    var value = null;
    if (!o) {
        return null;
    }

    switch (o.kind) {
    case ExceptHandler_kind:
        result = PyType_GenericNew(ExceptHandler_type, null, null);
        if (!result) return null;
        value = ast2obj_expr(o.v.ExceptHandler.type);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_type, value) == -1)
            return null;
        value = ast2obj_identifier(o.v.ExceptHandler.name);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_name, value) == -1)
            return null;
        value = ast2obj_list(o.v.ExceptHandler.body, ast2obj_stmt);
        if (!value) return null;
        if (_PyObject_SetAttrId(result, PyId_body, value) == -1)
            return null;
        break;
    }
    value = ast2obj_int(o.lineno);
    if (!value) return null;
    if (_PyObject_SetAttrId(result, PyId_lineno, value) < 0)
        return null;
    value = ast2obj_int(o.col_offset);
    if (!value) return null;
    if (_PyObject_SetAttrId(result, PyId_col_offset, value) < 0)
        return null;
    return result;
};

var ast2obj_arguments = function(_o) {
    var o = _o;
    var result = null;
    var value = null;
    if (!o) {
        return null;
    }

    result = PyType_GenericNew(arguments_type, null, null);
    if (!result) return null;
    value = ast2obj_list(o.args, ast2obj_arg);
    if (!value) return null;
    if (_PyObject_SetAttrId(result, PyId_args, value) == -1)
        return null;
    value = ast2obj_arg(o.vararg);
    if (!value) return null;
    if (_PyObject_SetAttrId(result, PyId_vararg, value) == -1)
        return null;
    value = ast2obj_list(o.kwonlyargs, ast2obj_arg);
    if (!value) return null;
    if (_PyObject_SetAttrId(result, PyId_kwonlyargs, value) == -1)
        return null;
    value = ast2obj_list(o.kw_defaults, ast2obj_expr);
    if (!value) return null;
    if (_PyObject_SetAttrId(result, PyId_kw_defaults, value) == -1)
        return null;
    value = ast2obj_arg(o.kwarg);
    if (!value) return null;
    if (_PyObject_SetAttrId(result, PyId_kwarg, value) == -1)
        return null;
    value = ast2obj_list(o.defaults, ast2obj_expr);
    if (!value) return null;
    if (_PyObject_SetAttrId(result, PyId_defaults, value) == -1)
        return null;
    return result;
};

var ast2obj_arg = function(_o) {
    var o = _o;
    var result = null;
    var value = null;
    if (!o) {
        return null;
    }

    result = PyType_GenericNew(arg_type, null, null);
    if (!result) return null;
    value = ast2obj_identifier(o.arg);
    if (!value) return null;
    if (_PyObject_SetAttrId(result, PyId_arg, value) == -1)
        return null;
    value = ast2obj_expr(o.annotation);
    if (!value) return null;
    if (_PyObject_SetAttrId(result, PyId_annotation, value) == -1)
        return null;
    value = ast2obj_int(o.lineno);
    if (!value) return null;
    if (_PyObject_SetAttrId(result, PyId_lineno, value) < 0)
        return null;
    value = ast2obj_int(o.col_offset);
    if (!value) return null;
    if (_PyObject_SetAttrId(result, PyId_col_offset, value) < 0)
        return null;
    return result;
};

var ast2obj_keyword = function(_o) {
    var o = _o;
    var result = null;
    var value = null;
    if (!o) {
        return null;
    }

    result = PyType_GenericNew(keyword_type, null, null);
    if (!result) return null;
    value = ast2obj_identifier(o.arg);
    if (!value) return null;
    if (_PyObject_SetAttrId(result, PyId_arg, value) == -1)
        return null;
    value = ast2obj_expr(o.value);
    if (!value) return null;
    if (_PyObject_SetAttrId(result, PyId_value, value) == -1)
        return null;
    return result;
};

var ast2obj_alias = function(_o) {
    var o = _o;
    var result = null;
    var value = null;
    if (!o) {
        return null;
    }

    result = PyType_GenericNew(alias_type, null, null);
    if (!result) return null;
    value = ast2obj_identifier(o.name);
    if (!value) return null;
    if (_PyObject_SetAttrId(result, PyId_name, value) == -1)
        return null;
    value = ast2obj_identifier(o.asname);
    if (!value) return null;
    if (_PyObject_SetAttrId(result, PyId_asname, value) == -1)
        return null;
    return result;
};

var ast2obj_withitem = function(_o) {
    var o = _o;
    var result = null;
    var value = null;
    if (!o) {
        return null;
    }

    result = PyType_GenericNew(withitem_type, null, null);
    if (!result) return null;
    value = ast2obj_expr(o.context_expr);
    if (!value) return null;
    if (_PyObject_SetAttrId(result, PyId_context_expr, value) == -1)
        return null;
    value = ast2obj_expr(o.optional_vars);
    if (!value) return null;
    if (_PyObject_SetAttrId(result, PyId_optional_vars, value) == -1)
        return null;
    return result;
};


var obj2ast_mod = function(obj) {
    var isinstance;

    var tmp = null;

    if (obj == null) {
        out = null;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Module_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var body;

        if (_PyObject_HasAttrId(obj, PyId_body)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_body);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("Module field \"body\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Py_asdl_seq_new(len);
            if (body == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(body, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"body\" missing from Module");
            return 1;
        }
        out = Module(body);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Interactive_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var body;

        if (_PyObject_HasAttrId(obj, PyId_body)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_body);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("Interactive field \"body\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Py_asdl_seq_new(len);
            if (body == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(body, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"body\" missing from Interactive");
            return 1;
        }
        out = Interactive(body);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Expression_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var body;

        if (_PyObject_HasAttrId(obj, PyId_body)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_body);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, body);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"body\" missing from Expression");
            return 1;
        }
        out = Expression(body);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Suite_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var body;

        if (_PyObject_HasAttrId(obj, PyId_body)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_body);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("Suite field \"body\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Py_asdl_seq_new(len);
            if (body == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(body, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"body\" missing from Suite");
            return 1;
        }
        out = Suite(body);
        if (out == null) return 1;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, "expected some sort of mod, but got %R", obj);
    return 1;
};

var obj2ast_stmt = function(obj) {
    var isinstance;

    var tmp = null;
    var lineno;
    var col_offset;

    if (obj == null) {
        out = null;
        return 0;
    }
    if (_PyObject_HasAttrId(obj, PyId_lineno)) {
        var res;
        tmp = _PyObject_GetAttrId(obj, PyId_lineno);
        if (tmp == null) return 1;
        res = obj2ast_int(tmp, lineno);
        if (res != 0) return 1;
        tmp.clear();
    } else {
        throw new batavia.builtins.TypeError("required field \"lineno\" missing from stmt");
        return 1;
    }
    if (_PyObject_HasAttrId(obj, PyId_col_offset)) {
        var res;
        tmp = _PyObject_GetAttrId(obj, PyId_col_offset);
        if (tmp == null) return 1;
        res = obj2ast_int(tmp, col_offset);
        if (res != 0) return 1;
        tmp.clear();
    } else {
        throw new batavia.builtins.TypeError("required field \"col_offset\" missing from stmt");
        return 1;
    }
    isinstance = batavia.isinstance(obj, FunctionDef_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var name;
        var args;
        var body;
        var decorator_list;
        var returns;

        if (_PyObject_HasAttrId(obj, PyId_name)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_name);
            if (tmp == null) return 1;
            res = obj2ast_identifier(tmp, name);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"name\" missing from FunctionDef");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_args)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_args);
            if (tmp == null) return 1;
            res = obj2ast_arguments(tmp, args);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"args\" missing from FunctionDef");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_body)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_body);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("FunctionDef field \"body\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Py_asdl_seq_new(len);
            if (body == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(body, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"body\" missing from FunctionDef");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_decorator_list)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_decorator_list);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("FunctionDef field \"decorator_list\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            decorator_list = _Py_asdl_seq_new(len);
            if (decorator_list == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(decorator_list, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"decorator_list\" missing from FunctionDef");
            return 1;
        }
        if (exists_not_none(obj, PyId_returns)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_returns);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, returns);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            returns = null;
        }
        out = FunctionDef(name, args, body, decorator_list, returns, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, AsyncFunctionDef_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var name;
        var args;
        var body;
        var decorator_list;
        var returns;

        if (_PyObject_HasAttrId(obj, PyId_name)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_name);
            if (tmp == null) return 1;
            res = obj2ast_identifier(tmp, name);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"name\" missing from AsyncFunctionDef");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_args)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_args);
            if (tmp == null) return 1;
            res = obj2ast_arguments(tmp, args);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"args\" missing from AsyncFunctionDef");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_body)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_body);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("AsyncFunctionDef field \"body\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Py_asdl_seq_new(len);
            if (body == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(body, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"body\" missing from AsyncFunctionDef");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_decorator_list)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_decorator_list);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("AsyncFunctionDef field \"decorator_list\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            decorator_list = _Py_asdl_seq_new(len);
            if (decorator_list == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(decorator_list, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"decorator_list\" missing from AsyncFunctionDef");
            return 1;
        }
        if (exists_not_none(obj, PyId_returns)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_returns);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, returns);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            returns = null;
        }
        out = AsyncFunctionDef(name, args, body, decorator_list, returns, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, ClassDef_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var name;
        var bases;
        var keywords;
        var body;
        var decorator_list;

        if (_PyObject_HasAttrId(obj, PyId_name)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_name);
            if (tmp == null) return 1;
            res = obj2ast_identifier(tmp, name);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"name\" missing from ClassDef");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_bases)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_bases);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("ClassDef field \"bases\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            bases = _Py_asdl_seq_new(len);
            if (bases == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(bases, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"bases\" missing from ClassDef");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_keywords)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_keywords);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("ClassDef field \"keywords\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            keywords = _Py_asdl_seq_new(len);
            if (keywords == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_keyword(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(keywords, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"keywords\" missing from ClassDef");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_body)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_body);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("ClassDef field \"body\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Py_asdl_seq_new(len);
            if (body == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(body, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"body\" missing from ClassDef");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_decorator_list)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_decorator_list);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("ClassDef field \"decorator_list\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            decorator_list = _Py_asdl_seq_new(len);
            if (decorator_list == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(decorator_list, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"decorator_list\" missing from ClassDef");
            return 1;
        }
        out = ClassDef(name, bases, keywords, body, decorator_list, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Return_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var value;

        if (exists_not_none(obj, PyId_value)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_value);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, value);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            value = null;
        }
        out = Return(value, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Delete_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var targets;

        if (_PyObject_HasAttrId(obj, PyId_targets)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_targets);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("Delete field \"targets\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            targets = _Py_asdl_seq_new(len);
            if (targets == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(targets, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"targets\" missing from Delete");
            return 1;
        }
        out = Delete(targets, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Assign_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var targets;
        var value;

        if (_PyObject_HasAttrId(obj, PyId_targets)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_targets);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("Assign field \"targets\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            targets = _Py_asdl_seq_new(len);
            if (targets == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(targets, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"targets\" missing from Assign");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_value)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_value);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, value);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"value\" missing from Assign");
            return 1;
        }
        out = Assign(targets, value, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, AugAssign_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var target;
        var op;
        var value;

        if (_PyObject_HasAttrId(obj, PyId_target)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_target);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, target);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"target\" missing from AugAssign");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_op)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_op);
            if (tmp == null) return 1;
            res = obj2ast_operator(tmp, op);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"op\" missing from AugAssign");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_value)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_value);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, value);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"value\" missing from AugAssign");
            return 1;
        }
        out = AugAssign(target, op, value, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, For_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var target;
        var iter;
        var body;
        var orelse;

        if (_PyObject_HasAttrId(obj, PyId_target)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_target);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, target);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"target\" missing from For");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_iter)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_iter);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, iter);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"iter\" missing from For");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_body)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_body);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("For field \"body\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Py_asdl_seq_new(len);
            if (body == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(body, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"body\" missing from For");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_orelse)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_orelse);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("For field \"orelse\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            orelse = _Py_asdl_seq_new(len);
            if (orelse == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(orelse, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"orelse\" missing from For");
            return 1;
        }
        out = For(target, iter, body, orelse, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, AsyncFor_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var target;
        var iter;
        var body;
        var orelse;

        if (_PyObject_HasAttrId(obj, PyId_target)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_target);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, target);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"target\" missing from AsyncFor");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_iter)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_iter);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, iter);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"iter\" missing from AsyncFor");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_body)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_body);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("AsyncFor field \"body\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Py_asdl_seq_new(len);
            if (body == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(body, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"body\" missing from AsyncFor");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_orelse)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_orelse);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("AsyncFor field \"orelse\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            orelse = _Py_asdl_seq_new(len);
            if (orelse == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(orelse, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"orelse\" missing from AsyncFor");
            return 1;
        }
        out = AsyncFor(target, iter, body, orelse, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, While_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var test;
        var body;
        var orelse;

        if (_PyObject_HasAttrId(obj, PyId_test)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_test);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, test);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"test\" missing from While");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_body)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_body);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("While field \"body\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Py_asdl_seq_new(len);
            if (body == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(body, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"body\" missing from While");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_orelse)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_orelse);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("While field \"orelse\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            orelse = _Py_asdl_seq_new(len);
            if (orelse == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(orelse, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"orelse\" missing from While");
            return 1;
        }
        out = While(test, body, orelse, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, If_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var test;
        var body;
        var orelse;

        if (_PyObject_HasAttrId(obj, PyId_test)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_test);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, test);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"test\" missing from If");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_body)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_body);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("If field \"body\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Py_asdl_seq_new(len);
            if (body == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(body, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"body\" missing from If");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_orelse)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_orelse);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("If field \"orelse\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            orelse = _Py_asdl_seq_new(len);
            if (orelse == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(orelse, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"orelse\" missing from If");
            return 1;
        }
        out = If(test, body, orelse, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, With_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var items;
        var body;

        if (_PyObject_HasAttrId(obj, PyId_items)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_items);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("With field \"items\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            items = _Py_asdl_seq_new(len);
            if (items == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_withitem(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(items, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"items\" missing from With");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_body)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_body);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("With field \"body\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Py_asdl_seq_new(len);
            if (body == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(body, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"body\" missing from With");
            return 1;
        }
        out = With(items, body, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, AsyncWith_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var items;
        var body;

        if (_PyObject_HasAttrId(obj, PyId_items)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_items);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("AsyncWith field \"items\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            items = _Py_asdl_seq_new(len);
            if (items == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_withitem(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(items, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"items\" missing from AsyncWith");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_body)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_body);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("AsyncWith field \"body\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Py_asdl_seq_new(len);
            if (body == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(body, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"body\" missing from AsyncWith");
            return 1;
        }
        out = AsyncWith(items, body, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Raise_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var exc;
        var cause;

        if (exists_not_none(obj, PyId_exc)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_exc);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, exc);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            exc = null;
        }
        if (exists_not_none(obj, PyId_cause)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_cause);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, cause);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            cause = null;
        }
        out = Raise(exc, cause, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Try_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var body;
        var handlers;
        var orelse;
        var finalbody;

        if (_PyObject_HasAttrId(obj, PyId_body)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_body);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("Try field \"body\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Py_asdl_seq_new(len);
            if (body == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(body, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"body\" missing from Try");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_handlers)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_handlers);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("Try field \"handlers\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            handlers = _Py_asdl_seq_new(len);
            if (handlers == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_excepthandler(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(handlers, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"handlers\" missing from Try");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_orelse)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_orelse);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("Try field \"orelse\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            orelse = _Py_asdl_seq_new(len);
            if (orelse == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(orelse, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"orelse\" missing from Try");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_finalbody)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_finalbody);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("Try field \"finalbody\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            finalbody = _Py_asdl_seq_new(len);
            if (finalbody == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(finalbody, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"finalbody\" missing from Try");
            return 1;
        }
        out = Try(body, handlers, orelse, finalbody, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Assert_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var test;
        var msg;

        if (_PyObject_HasAttrId(obj, PyId_test)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_test);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, test);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"test\" missing from Assert");
            return 1;
        }
        if (exists_not_none(obj, PyId_msg)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_msg);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, msg);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            msg = null;
        }
        out = Assert(test, msg, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Import_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var names;

        if (_PyObject_HasAttrId(obj, PyId_names)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_names);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("Import field \"names\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            names = _Py_asdl_seq_new(len);
            if (names == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_alias(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(names, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"names\" missing from Import");
            return 1;
        }
        out = Import(names, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, ImportFrom_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var module;
        var names;
        var level;

        if (exists_not_none(obj, PyId_module)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_module);
            if (tmp == null) return 1;
            res = obj2ast_identifier(tmp, module);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            module = null;
        }
        if (_PyObject_HasAttrId(obj, PyId_names)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_names);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("ImportFrom field \"names\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            names = _Py_asdl_seq_new(len);
            if (names == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_alias(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(names, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"names\" missing from ImportFrom");
            return 1;
        }
        if (exists_not_none(obj, PyId_level)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_level);
            if (tmp == null) return 1;
            res = obj2ast_int(tmp, level);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            level = 0;
        }
        out = ImportFrom(module, names, level, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Global_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var names;

        if (_PyObject_HasAttrId(obj, PyId_names)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_names);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("Global field \"names\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            names = _Py_asdl_seq_new(len);
            if (names == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_identifier(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(names, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"names\" missing from Global");
            return 1;
        }
        out = Global(names, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Nonlocal_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var names;

        if (_PyObject_HasAttrId(obj, PyId_names)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_names);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("Nonlocal field \"names\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            names = _Py_asdl_seq_new(len);
            if (names == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_identifier(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(names, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"names\" missing from Nonlocal");
            return 1;
        }
        out = Nonlocal(names, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Expr_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var value;

        if (_PyObject_HasAttrId(obj, PyId_value)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_value);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, value);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"value\" missing from Expr");
            return 1;
        }
        out = Expr(value, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Pass_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {

        out = Pass(lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Break_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {

        out = Break(lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Continue_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {

        out = Continue(lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, "expected some sort of stmt, but got %R", obj);
    return 1;
};

var obj2ast_expr = function(obj) {
    var isinstance;

    var tmp = null;
    var lineno;
    var col_offset;

    if (obj == null) {
        out = null;
        return 0;
    }
    if (_PyObject_HasAttrId(obj, PyId_lineno)) {
        var res;
        tmp = _PyObject_GetAttrId(obj, PyId_lineno);
        if (tmp == null) return 1;
        res = obj2ast_int(tmp, lineno);
        if (res != 0) return 1;
        tmp.clear();
    } else {
        throw new batavia.builtins.TypeError("required field \"lineno\" missing from expr");
        return 1;
    }
    if (_PyObject_HasAttrId(obj, PyId_col_offset)) {
        var res;
        tmp = _PyObject_GetAttrId(obj, PyId_col_offset);
        if (tmp == null) return 1;
        res = obj2ast_int(tmp, col_offset);
        if (res != 0) return 1;
        tmp.clear();
    } else {
        throw new batavia.builtins.TypeError("required field \"col_offset\" missing from expr");
        return 1;
    }
    isinstance = batavia.isinstance(obj, BoolOp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var op;
        var values;

        if (_PyObject_HasAttrId(obj, PyId_op)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_op);
            if (tmp == null) return 1;
            res = obj2ast_boolop(tmp, op);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"op\" missing from BoolOp");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_values)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_values);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("BoolOp field \"values\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            values = _Py_asdl_seq_new(len);
            if (values == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(values, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"values\" missing from BoolOp");
            return 1;
        }
        out = BoolOp(op, values, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, BinOp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var left;
        var op;
        var right;

        if (_PyObject_HasAttrId(obj, PyId_left)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_left);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, left);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"left\" missing from BinOp");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_op)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_op);
            if (tmp == null) return 1;
            res = obj2ast_operator(tmp, op);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"op\" missing from BinOp");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_right)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_right);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, right);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"right\" missing from BinOp");
            return 1;
        }
        out = BinOp(left, op, right, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, UnaryOp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var op;
        var operand;

        if (_PyObject_HasAttrId(obj, PyId_op)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_op);
            if (tmp == null) return 1;
            res = obj2ast_unaryop(tmp, op);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"op\" missing from UnaryOp");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_operand)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_operand);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, operand);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"operand\" missing from UnaryOp");
            return 1;
        }
        out = UnaryOp(op, operand, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Lambda_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var args;
        var body;

        if (_PyObject_HasAttrId(obj, PyId_args)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_args);
            if (tmp == null) return 1;
            res = obj2ast_arguments(tmp, args);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"args\" missing from Lambda");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_body)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_body);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, body);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"body\" missing from Lambda");
            return 1;
        }
        out = Lambda(args, body, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, IfExp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var test;
        var body;
        var orelse;

        if (_PyObject_HasAttrId(obj, PyId_test)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_test);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, test);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"test\" missing from IfExp");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_body)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_body);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, body);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"body\" missing from IfExp");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_orelse)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_orelse);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, orelse);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"orelse\" missing from IfExp");
            return 1;
        }
        out = IfExp(test, body, orelse, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Dict_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var keys;
        var values;

        if (_PyObject_HasAttrId(obj, PyId_keys)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_keys);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("Dict field \"keys\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            keys = _Py_asdl_seq_new(len);
            if (keys == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(keys, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"keys\" missing from Dict");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_values)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_values);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("Dict field \"values\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            values = _Py_asdl_seq_new(len);
            if (values == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(values, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"values\" missing from Dict");
            return 1;
        }
        out = Dict(keys, values, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Set_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var elts;

        if (_PyObject_HasAttrId(obj, PyId_elts)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_elts);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("Set field \"elts\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            elts = _Py_asdl_seq_new(len);
            if (elts == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(elts, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"elts\" missing from Set");
            return 1;
        }
        out = Set(elts, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, ListComp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var elt;
        var generators;

        if (_PyObject_HasAttrId(obj, PyId_elt)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_elt);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, elt);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"elt\" missing from ListComp");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_generators)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_generators);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("ListComp field \"generators\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            generators = _Py_asdl_seq_new(len);
            if (generators == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_comprehension(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(generators, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"generators\" missing from ListComp");
            return 1;
        }
        out = ListComp(elt, generators, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, SetComp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var elt;
        var generators;

        if (_PyObject_HasAttrId(obj, PyId_elt)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_elt);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, elt);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"elt\" missing from SetComp");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_generators)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_generators);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("SetComp field \"generators\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            generators = _Py_asdl_seq_new(len);
            if (generators == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_comprehension(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(generators, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"generators\" missing from SetComp");
            return 1;
        }
        out = SetComp(elt, generators, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, DictComp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var key;
        var value;
        var generators;

        if (_PyObject_HasAttrId(obj, PyId_key)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_key);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, key);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"key\" missing from DictComp");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_value)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_value);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, value);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"value\" missing from DictComp");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_generators)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_generators);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("DictComp field \"generators\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            generators = _Py_asdl_seq_new(len);
            if (generators == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_comprehension(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(generators, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"generators\" missing from DictComp");
            return 1;
        }
        out = DictComp(key, value, generators, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, GeneratorExp_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var elt;
        var generators;

        if (_PyObject_HasAttrId(obj, PyId_elt)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_elt);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, elt);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"elt\" missing from GeneratorExp");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_generators)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_generators);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("GeneratorExp field \"generators\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            generators = _Py_asdl_seq_new(len);
            if (generators == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_comprehension(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(generators, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"generators\" missing from GeneratorExp");
            return 1;
        }
        out = GeneratorExp(elt, generators, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Await_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var value;

        if (_PyObject_HasAttrId(obj, PyId_value)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_value);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, value);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"value\" missing from Await");
            return 1;
        }
        out = Await(value, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Yield_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var value;

        if (exists_not_none(obj, PyId_value)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_value);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, value);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            value = null;
        }
        out = Yield(value, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, YieldFrom_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var value;

        if (_PyObject_HasAttrId(obj, PyId_value)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_value);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, value);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"value\" missing from YieldFrom");
            return 1;
        }
        out = YieldFrom(value, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Compare_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var left;
        var ops;
        var comparators;

        if (_PyObject_HasAttrId(obj, PyId_left)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_left);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, left);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"left\" missing from Compare");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_ops)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_ops);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("Compare field \"ops\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            ops = _Py_asdl_int_seq_new(len);
            if (ops == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_cmpop(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(ops, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"ops\" missing from Compare");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_comparators)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_comparators);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("Compare field \"comparators\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            comparators = _Py_asdl_seq_new(len);
            if (comparators == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(comparators, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"comparators\" missing from Compare");
            return 1;
        }
        out = Compare(left, ops, comparators, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Call_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var func;
        var args;
        var keywords;

        if (_PyObject_HasAttrId(obj, PyId_func)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_func);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, func);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"func\" missing from Call");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_args)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_args);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("Call field \"args\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            args = _Py_asdl_seq_new(len);
            if (args == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(args, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"args\" missing from Call");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_keywords)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_keywords);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("Call field \"keywords\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            keywords = _Py_asdl_seq_new(len);
            if (keywords == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_keyword(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(keywords, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"keywords\" missing from Call");
            return 1;
        }
        out = Call(func, args, keywords, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Num_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var n;

        if (_PyObject_HasAttrId(obj, PyId_n)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_n);
            if (tmp == null) return 1;
            res = obj2ast_object(tmp, n);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"n\" missing from Num");
            return 1;
        }
        out = Num(n, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Str_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var s;

        if (_PyObject_HasAttrId(obj, PyId_s)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_s);
            if (tmp == null) return 1;
            res = obj2ast_string(tmp, s);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"s\" missing from Str");
            return 1;
        }
        out = Str(s, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, FormattedValue_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var value;
        var conversion;
        var format_spec;

        if (_PyObject_HasAttrId(obj, PyId_value)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_value);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, value);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"value\" missing from FormattedValue");
            return 1;
        }
        if (exists_not_none(obj, PyId_conversion)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_conversion);
            if (tmp == null) return 1;
            res = obj2ast_int(tmp, conversion);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            conversion = 0;
        }
        if (exists_not_none(obj, PyId_format_spec)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_format_spec);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, format_spec);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            format_spec = null;
        }
        out = FormattedValue(value, conversion, format_spec, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, JoinedStr_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var values;

        if (_PyObject_HasAttrId(obj, PyId_values)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_values);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("JoinedStr field \"values\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            values = _Py_asdl_seq_new(len);
            if (values == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(values, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"values\" missing from JoinedStr");
            return 1;
        }
        out = JoinedStr(values, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Bytes_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var s;

        if (_PyObject_HasAttrId(obj, PyId_s)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_s);
            if (tmp == null) return 1;
            res = obj2ast_bytes(tmp, s);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"s\" missing from Bytes");
            return 1;
        }
        out = Bytes(s, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, NameConstant_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var value;

        if (_PyObject_HasAttrId(obj, PyId_value)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_value);
            if (tmp == null) return 1;
            res = obj2ast_singleton(tmp, value);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"value\" missing from NameConstant");
            return 1;
        }
        out = NameConstant(value, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Ellipsis_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {

        out = Ellipsis(lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Constant_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var value;

        if (_PyObject_HasAttrId(obj, PyId_value)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_value);
            if (tmp == null) return 1;
            res = obj2ast_constant(tmp, value);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"value\" missing from Constant");
            return 1;
        }
        out = Constant(value, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Attribute_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var value;
        var attr;
        var ctx;

        if (_PyObject_HasAttrId(obj, PyId_value)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_value);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, value);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"value\" missing from Attribute");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_attr)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_attr);
            if (tmp == null) return 1;
            res = obj2ast_identifier(tmp, attr);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"attr\" missing from Attribute");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_ctx)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_ctx);
            if (tmp == null) return 1;
            res = obj2ast_expr_context(tmp, ctx);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"ctx\" missing from Attribute");
            return 1;
        }
        out = Attribute(value, attr, ctx, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Subscript_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var value;
        var slice;
        var ctx;

        if (_PyObject_HasAttrId(obj, PyId_value)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_value);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, value);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"value\" missing from Subscript");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_slice)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_slice);
            if (tmp == null) return 1;
            res = obj2ast_slice(tmp, slice);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"slice\" missing from Subscript");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_ctx)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_ctx);
            if (tmp == null) return 1;
            res = obj2ast_expr_context(tmp, ctx);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"ctx\" missing from Subscript");
            return 1;
        }
        out = Subscript(value, slice, ctx, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Starred_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var value;
        var ctx;

        if (_PyObject_HasAttrId(obj, PyId_value)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_value);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, value);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"value\" missing from Starred");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_ctx)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_ctx);
            if (tmp == null) return 1;
            res = obj2ast_expr_context(tmp, ctx);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"ctx\" missing from Starred");
            return 1;
        }
        out = Starred(value, ctx, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Name_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var id;
        var ctx;

        if (_PyObject_HasAttrId(obj, PyId_id)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_id);
            if (tmp == null) return 1;
            res = obj2ast_identifier(tmp, id);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"id\" missing from Name");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_ctx)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_ctx);
            if (tmp == null) return 1;
            res = obj2ast_expr_context(tmp, ctx);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"ctx\" missing from Name");
            return 1;
        }
        out = Name(id, ctx, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, List_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var elts;
        var ctx;

        if (_PyObject_HasAttrId(obj, PyId_elts)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_elts);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("List field \"elts\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            elts = _Py_asdl_seq_new(len);
            if (elts == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(elts, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"elts\" missing from List");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_ctx)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_ctx);
            if (tmp == null) return 1;
            res = obj2ast_expr_context(tmp, ctx);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"ctx\" missing from List");
            return 1;
        }
        out = List(elts, ctx, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Tuple_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var elts;
        var ctx;

        if (_PyObject_HasAttrId(obj, PyId_elts)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_elts);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("Tuple field \"elts\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            elts = _Py_asdl_seq_new(len);
            if (elts == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_expr(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(elts, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"elts\" missing from Tuple");
            return 1;
        }
        if (_PyObject_HasAttrId(obj, PyId_ctx)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_ctx);
            if (tmp == null) return 1;
            res = obj2ast_expr_context(tmp, ctx);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"ctx\" missing from Tuple");
            return 1;
        }
        out = Tuple(elts, ctx, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, "expected some sort of expr, but got %R", obj);
    return 1;
};

var obj2ast_expr_context = function(obj) {
    var isinstance;

    isinstance = batavia.isinstance(obj, Load_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = Load;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Store_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = Store;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Del_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = Del;
        return 0;
    }
    isinstance = batavia.isinstance(obj, AugLoad_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = AugLoad;
        return 0;
    }
    isinstance = batavia.isinstance(obj, AugStore_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = AugStore;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Param_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = Param;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, "expected some sort of expr_context, but got %R", obj);
    return 1;
};

var obj2ast_slice = function(obj) {
    var isinstance;

    var tmp = null;

    if (obj == null) {
        out = null;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Slice_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var lower;
        var upper;
        var step;

        if (exists_not_none(obj, PyId_lower)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_lower);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, lower);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            lower = null;
        }
        if (exists_not_none(obj, PyId_upper)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_upper);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, upper);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            upper = null;
        }
        if (exists_not_none(obj, PyId_step)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_step);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, step);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            step = null;
        }
        out = Slice(lower, upper, step);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, ExtSlice_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var dims;

        if (_PyObject_HasAttrId(obj, PyId_dims)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_dims);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("ExtSlice field \"dims\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            dims = _Py_asdl_seq_new(len);
            if (dims == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_slice(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(dims, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"dims\" missing from ExtSlice");
            return 1;
        }
        out = ExtSlice(dims);
        if (out == null) return 1;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Index_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var value;

        if (_PyObject_HasAttrId(obj, PyId_value)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_value);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, value);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"value\" missing from Index");
            return 1;
        }
        out = Index(value);
        if (out == null) return 1;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, "expected some sort of slice, but got %R", obj);
    return 1;
};

var obj2ast_boolop = function(obj) {
    var isinstance;

    isinstance = batavia.isinstance(obj, And_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = And;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Or_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = Or;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, "expected some sort of boolop, but got %R", obj);
    return 1;
};

var obj2ast_operator = function(obj) {
    var isinstance;

    isinstance = batavia.isinstance(obj, Add_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = Add;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Sub_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = Sub;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Mult_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = Mult;
        return 0;
    }
    isinstance = batavia.isinstance(obj, MatMult_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = MatMult;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Div_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = Div;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Mod_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = Mod;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Pow_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = Pow;
        return 0;
    }
    isinstance = batavia.isinstance(obj, LShift_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = LShift;
        return 0;
    }
    isinstance = batavia.isinstance(obj, RShift_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = RShift;
        return 0;
    }
    isinstance = batavia.isinstance(obj, BitOr_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = BitOr;
        return 0;
    }
    isinstance = batavia.isinstance(obj, BitXor_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = BitXor;
        return 0;
    }
    isinstance = batavia.isinstance(obj, BitAnd_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = BitAnd;
        return 0;
    }
    isinstance = batavia.isinstance(obj, FloorDiv_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = FloorDiv;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, "expected some sort of operator, but got %R", obj);
    return 1;
};

var obj2ast_unaryop = function(obj) {
    var isinstance;

    isinstance = batavia.isinstance(obj, Invert_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = Invert;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Not_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = Not;
        return 0;
    }
    isinstance = batavia.isinstance(obj, UAdd_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = UAdd;
        return 0;
    }
    isinstance = batavia.isinstance(obj, USub_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = USub;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, "expected some sort of unaryop, but got %R", obj);
    return 1;
};

var obj2ast_cmpop = function(obj) {
    var isinstance;

    isinstance = batavia.isinstance(obj, Eq_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = Eq;
        return 0;
    }
    isinstance = batavia.isinstance(obj, NotEq_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = NotEq;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Lt_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = Lt;
        return 0;
    }
    isinstance = batavia.isinstance(obj, LtE_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = LtE;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Gt_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = Gt;
        return 0;
    }
    isinstance = batavia.isinstance(obj, GtE_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = GtE;
        return 0;
    }
    isinstance = batavia.isinstance(obj, Is_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = Is;
        return 0;
    }
    isinstance = batavia.isinstance(obj, IsNot_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = IsNot;
        return 0;
    }
    isinstance = batavia.isinstance(obj, In_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = In;
        return 0;
    }
    isinstance = batavia.isinstance(obj, NotIn_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        out = NotIn;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, "expected some sort of cmpop, but got %R", obj);
    return 1;
};

var obj2ast_comprehension = function(obj) {
    var tmp = null;
    var target;
    var iter;
    var ifs;

    if (_PyObject_HasAttrId(obj, PyId_target)) {
        var res;
        tmp = _PyObject_GetAttrId(obj, PyId_target);
        if (tmp == null) return 1;
        res = obj2ast_expr(tmp, target);
        if (res != 0) return 1;
        tmp.clear();
    } else {
        throw new batavia.builtins.TypeError("required field \"target\" missing from comprehension");
        return 1;
    }
    if (_PyObject_HasAttrId(obj, PyId_iter)) {
        var res;
        tmp = _PyObject_GetAttrId(obj, PyId_iter);
        if (tmp == null) return 1;
        res = obj2ast_expr(tmp, iter);
        if (res != 0) return 1;
        tmp.clear();
    } else {
        throw new batavia.builtins.TypeError("required field \"iter\" missing from comprehension");
        return 1;
    }
    if (_PyObject_HasAttrId(obj, PyId_ifs)) {
        var res;
        var len;
        var i;
        tmp = _PyObject_GetAttrId(obj, PyId_ifs);
        if (tmp == null) return 1;
        if (!PyList_Check(tmp)) {
            throw new batavia.builtins.TypeError("comprehension field \"ifs\" must be a list, not a " + tmp.ob_type.tp_name);
            return 1;
        }
        len = PyList_GET_SIZE(tmp);
        ifs = _Py_asdl_seq_new(len);
        if (ifs == null) return 1;
        for (i = 0; i < len; i++) {
            var value;
            res = obj2ast_expr(PyList_GET_ITEM(tmp, i), value);
            if (res != 0) return 1;
            asdl_seq_SET(ifs, i, value);
        }
        tmp.clear();
    } else {
        throw new batavia.builtins.TypeError("required field \"ifs\" missing from comprehension");
        return 1;
    }
    out = comprehension(target, iter, ifs);
    return 0;
};

var obj2ast_excepthandler = function(obj) {
    var isinstance;

    var tmp = null;
    var lineno;
    var col_offset;

    if (obj == null) {
        out = null;
        return 0;
    }
    if (_PyObject_HasAttrId(obj, PyId_lineno)) {
        var res;
        tmp = _PyObject_GetAttrId(obj, PyId_lineno);
        if (tmp == null) return 1;
        res = obj2ast_int(tmp, lineno);
        if (res != 0) return 1;
        tmp.clear();
    } else {
        throw new batavia.builtins.TypeError("required field \"lineno\" missing from excepthandler");
        return 1;
    }
    if (_PyObject_HasAttrId(obj, PyId_col_offset)) {
        var res;
        tmp = _PyObject_GetAttrId(obj, PyId_col_offset);
        if (tmp == null) return 1;
        res = obj2ast_int(tmp, col_offset);
        if (res != 0) return 1;
        tmp.clear();
    } else {
        throw new batavia.builtins.TypeError("required field \"col_offset\" missing from excepthandler");
        return 1;
    }
    isinstance = batavia.isinstance(obj, ExceptHandler_type);
    if (isinstance == -1) {
        return 1;
    }
    if (isinstance) {
        var type;
        var name;
        var body;

        if (exists_not_none(obj, PyId_type)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_type);
            if (tmp == null) return 1;
            res = obj2ast_expr(tmp, type);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            type = null;
        }
        if (exists_not_none(obj, PyId_name)) {
            var res;
            tmp = _PyObject_GetAttrId(obj, PyId_name);
            if (tmp == null) return 1;
            res = obj2ast_identifier(tmp, name);
            if (res != 0) return 1;
            tmp.clear();
        } else {
            name = null;
        }
        if (_PyObject_HasAttrId(obj, PyId_body)) {
            var res;
            var len;
            var i;
            tmp = _PyObject_GetAttrId(obj, PyId_body);
            if (tmp == null) return 1;
            if (!PyList_Check(tmp)) {
                throw new batavia.builtins.TypeError("ExceptHandler field \"body\" must be a list, not a " + tmp.ob_type.tp_name);
                return 1;
            }
            len = PyList_GET_SIZE(tmp);
            body = _Py_asdl_seq_new(len);
            if (body == null) return 1;
            for (i = 0; i < len; i++) {
                var value;
                res = obj2ast_stmt(PyList_GET_ITEM(tmp, i), value);
                if (res != 0) return 1;
                asdl_seq_SET(body, i, value);
            }
            tmp.clear();
        } else {
            throw new batavia.builtins.TypeError("required field \"body\" missing from ExceptHandler");
            return 1;
        }
        out = ExceptHandler(type, name, body, lineno, col_offset);
        if (out == null) return 1;
        return 0;
    }

    PyErr_Format(PyExc_TypeError, "expected some sort of excepthandler, but got %R", obj);
    return 1;
};

var obj2ast_arguments = function(obj) {
    var tmp = null;
    var args;
    var vararg;
    var kwonlyargs;
    var kw_defaults;
    var kwarg;
    var defaults;

    if (_PyObject_HasAttrId(obj, PyId_args)) {
        var res;
        var len;
        var i;
        tmp = _PyObject_GetAttrId(obj, PyId_args);
        if (tmp == null) return 1;
        if (!PyList_Check(tmp)) {
            throw new batavia.builtins.TypeError("arguments field \"args\" must be a list, not a " + tmp.ob_type.tp_name);
            return 1;
        }
        len = PyList_GET_SIZE(tmp);
        args = _Py_asdl_seq_new(len);
        if (args == null) return 1;
        for (i = 0; i < len; i++) {
            var value;
            res = obj2ast_arg(PyList_GET_ITEM(tmp, i), value);
            if (res != 0) return 1;
            asdl_seq_SET(args, i, value);
        }
        tmp.clear();
    } else {
        throw new batavia.builtins.TypeError("required field \"args\" missing from arguments");
        return 1;
    }
    if (exists_not_none(obj, PyId_vararg)) {
        var res;
        tmp = _PyObject_GetAttrId(obj, PyId_vararg);
        if (tmp == null) return 1;
        res = obj2ast_arg(tmp, vararg);
        if (res != 0) return 1;
        tmp.clear();
    } else {
        vararg = null;
    }
    if (_PyObject_HasAttrId(obj, PyId_kwonlyargs)) {
        var res;
        var len;
        var i;
        tmp = _PyObject_GetAttrId(obj, PyId_kwonlyargs);
        if (tmp == null) return 1;
        if (!PyList_Check(tmp)) {
            throw new batavia.builtins.TypeError("arguments field \"kwonlyargs\" must be a list, not a " + tmp.ob_type.tp_name);
            return 1;
        }
        len = PyList_GET_SIZE(tmp);
        kwonlyargs = _Py_asdl_seq_new(len);
        if (kwonlyargs == null) return 1;
        for (i = 0; i < len; i++) {
            var value;
            res = obj2ast_arg(PyList_GET_ITEM(tmp, i), value);
            if (res != 0) return 1;
            asdl_seq_SET(kwonlyargs, i, value);
        }
        tmp.clear();
    } else {
        throw new batavia.builtins.TypeError("required field \"kwonlyargs\" missing from arguments");
        return 1;
    }
    if (_PyObject_HasAttrId(obj, PyId_kw_defaults)) {
        var res;
        var len;
        var i;
        tmp = _PyObject_GetAttrId(obj, PyId_kw_defaults);
        if (tmp == null) return 1;
        if (!PyList_Check(tmp)) {
            throw new batavia.builtins.TypeError("arguments field \"kw_defaults\" must be a list, not a " + tmp.ob_type.tp_name);
            return 1;
        }
        len = PyList_GET_SIZE(tmp);
        kw_defaults = _Py_asdl_seq_new(len);
        if (kw_defaults == null) return 1;
        for (i = 0; i < len; i++) {
            var value;
            res = obj2ast_expr(PyList_GET_ITEM(tmp, i), value);
            if (res != 0) return 1;
            asdl_seq_SET(kw_defaults, i, value);
        }
        tmp.clear();
    } else {
        throw new batavia.builtins.TypeError("required field \"kw_defaults\" missing from arguments");
        return 1;
    }
    if (exists_not_none(obj, PyId_kwarg)) {
        var res;
        tmp = _PyObject_GetAttrId(obj, PyId_kwarg);
        if (tmp == null) return 1;
        res = obj2ast_arg(tmp, kwarg);
        if (res != 0) return 1;
        tmp.clear();
    } else {
        kwarg = null;
    }
    if (_PyObject_HasAttrId(obj, PyId_defaults)) {
        var res;
        var len;
        var i;
        tmp = _PyObject_GetAttrId(obj, PyId_defaults);
        if (tmp == null) return 1;
        if (!PyList_Check(tmp)) {
            throw new batavia.builtins.TypeError("arguments field \"defaults\" must be a list, not a " + tmp.ob_type.tp_name);
            return 1;
        }
        len = PyList_GET_SIZE(tmp);
        defaults = _Py_asdl_seq_new(len);
        if (defaults == null) return 1;
        for (i = 0; i < len; i++) {
            var value;
            res = obj2ast_expr(PyList_GET_ITEM(tmp, i), value);
            if (res != 0) return 1;
            asdl_seq_SET(defaults, i, value);
        }
        tmp.clear();
    } else {
        throw new batavia.builtins.TypeError("required field \"defaults\" missing from arguments");
        return 1;
    }
    out = arguments(args, vararg, kwonlyargs, kw_defaults, kwarg, defaults);
    return 0;
};

var obj2ast_arg = function(obj) {
    var tmp = null;
    var arg;
    var annotation;
    var lineno;
    var col_offset;

    if (_PyObject_HasAttrId(obj, PyId_arg)) {
        var res;
        tmp = _PyObject_GetAttrId(obj, PyId_arg);
        if (tmp == null) return 1;
        res = obj2ast_identifier(tmp, arg);
        if (res != 0) return 1;
        tmp.clear();
    } else {
        throw new batavia.builtins.TypeError("required field \"arg\" missing from arg");
        return 1;
    }
    if (exists_not_none(obj, PyId_annotation)) {
        var res;
        tmp = _PyObject_GetAttrId(obj, PyId_annotation);
        if (tmp == null) return 1;
        res = obj2ast_expr(tmp, annotation);
        if (res != 0) return 1;
        tmp.clear();
    } else {
        annotation = null;
    }
    if (_PyObject_HasAttrId(obj, PyId_lineno)) {
        var res;
        tmp = _PyObject_GetAttrId(obj, PyId_lineno);
        if (tmp == null) return 1;
        res = obj2ast_int(tmp, lineno);
        if (res != 0) return 1;
        tmp.clear();
    } else {
        throw new batavia.builtins.TypeError("required field \"lineno\" missing from arg");
        return 1;
    }
    if (_PyObject_HasAttrId(obj, PyId_col_offset)) {
        var res;
        tmp = _PyObject_GetAttrId(obj, PyId_col_offset);
        if (tmp == null) return 1;
        res = obj2ast_int(tmp, col_offset);
        if (res != 0) return 1;
        tmp.clear();
    } else {
        throw new batavia.builtins.TypeError("required field \"col_offset\" missing from arg");
        return 1;
    }
    out = arg(arg, annotation, lineno, col_offset);
    return 0;
};

var obj2ast_keyword = function(obj) {
    var tmp = null;
    var arg;
    var value;

    if (exists_not_none(obj, PyId_arg)) {
        var res;
        tmp = _PyObject_GetAttrId(obj, PyId_arg);
        if (tmp == null) return 1;
        res = obj2ast_identifier(tmp, arg);
        if (res != 0) return 1;
        tmp.clear();
    } else {
        arg = null;
    }
    if (_PyObject_HasAttrId(obj, PyId_value)) {
        var res;
        tmp = _PyObject_GetAttrId(obj, PyId_value);
        if (tmp == null) return 1;
        res = obj2ast_expr(tmp, value);
        if (res != 0) return 1;
        tmp.clear();
    } else {
        throw new batavia.builtins.TypeError("required field \"value\" missing from keyword");
        return 1;
    }
    out = keyword(arg, value);
    return 0;
};

var obj2ast_alias = function(obj) {
    var tmp = null;
    var name;
    var asname;

    if (_PyObject_HasAttrId(obj, PyId_name)) {
        var res;
        tmp = _PyObject_GetAttrId(obj, PyId_name);
        if (tmp == null) return 1;
        res = obj2ast_identifier(tmp, name);
        if (res != 0) return 1;
        tmp.clear();
    } else {
        throw new batavia.builtins.TypeError("required field \"name\" missing from alias");
        return 1;
    }
    if (exists_not_none(obj, PyId_asname)) {
        var res;
        tmp = _PyObject_GetAttrId(obj, PyId_asname);
        if (tmp == null) return 1;
        res = obj2ast_identifier(tmp, asname);
        if (res != 0) return 1;
        tmp.clear();
    } else {
        asname = null;
    }
    out = alias(name, asname);
    return 0;
};

var obj2ast_withitem = function(obj) {
    var tmp = null;
    var context_expr;
    var optional_vars;

    if (_PyObject_HasAttrId(obj, PyId_context_expr)) {
        var res;
        tmp = _PyObject_GetAttrId(obj, PyId_context_expr);
        if (tmp == null) return 1;
        res = obj2ast_expr(tmp, context_expr);
        if (res != 0) return 1;
        tmp.clear();
    } else {
        throw new batavia.builtins.TypeError("required field \"context_expr\" missing from withitem");
        return 1;
    }
    if (exists_not_none(obj, PyId_optional_vars)) {
        var res;
        tmp = _PyObject_GetAttrId(obj, PyId_optional_vars);
        if (tmp == null) return 1;
        res = obj2ast_expr(tmp, optional_vars);
        if (res != 0) return 1;
        tmp.clear();
    } else {
        optional_vars = null;
    }
    out = withitem(context_expr, optional_vars);
    return 0;
};


function _astmodule() {
    this._ast = null;
};
var PyInit__ast = function() {
    var m = null;
    var d = null;
    if (!init_types()) return null;
    m = PyModule_Create(_astmodule);
    if (!m) return null;
    d = PyModule_GetDict(m);
    if (PyDict_SetItemString(d, "AST", AST_object) < 0) return null;
    if (PyModule_AddIntMacro(m, PyCF_ONLY_AST) < 0)
        return null;
    if (PyDict_SetItemString(d, "mod", mod_type) < 0) return null;
    if (PyDict_SetItemString(d, "Module", Module_type) < 0) return null;
    if (PyDict_SetItemString(d, "Interactive", Interactive_type) < 0) return null;
    if (PyDict_SetItemString(d, "Expression", Expression_type) < 0) return null;
    if (PyDict_SetItemString(d, "Suite", Suite_type) < 0) return null;
    if (PyDict_SetItemString(d, "stmt", stmt_type) < 0) return null;
    if (PyDict_SetItemString(d, "FunctionDef", FunctionDef_type) < 0) return null;
    if (PyDict_SetItemString(d, "AsyncFunctionDef", AsyncFunctionDef_type) < 0) return null;
    if (PyDict_SetItemString(d, "ClassDef", ClassDef_type) < 0) return null;
    if (PyDict_SetItemString(d, "Return", Return_type) < 0) return null;
    if (PyDict_SetItemString(d, "Delete", Delete_type) < 0) return null;
    if (PyDict_SetItemString(d, "Assign", Assign_type) < 0) return null;
    if (PyDict_SetItemString(d, "AugAssign", AugAssign_type) < 0) return null;
    if (PyDict_SetItemString(d, "For", For_type) < 0) return null;
    if (PyDict_SetItemString(d, "AsyncFor", AsyncFor_type) < 0) return null;
    if (PyDict_SetItemString(d, "While", While_type) < 0) return null;
    if (PyDict_SetItemString(d, "If", If_type) < 0) return null;
    if (PyDict_SetItemString(d, "With", With_type) < 0) return null;
    if (PyDict_SetItemString(d, "AsyncWith", AsyncWith_type) < 0) return null;
    if (PyDict_SetItemString(d, "Raise", Raise_type) < 0) return null;
    if (PyDict_SetItemString(d, "Try", Try_type) < 0) return null;
    if (PyDict_SetItemString(d, "Assert", Assert_type) < 0) return null;
    if (PyDict_SetItemString(d, "Import", Import_type) < 0) return null;
    if (PyDict_SetItemString(d, "ImportFrom", ImportFrom_type) < 0) return null;
    if (PyDict_SetItemString(d, "Global", Global_type) < 0) return null;
    if (PyDict_SetItemString(d, "Nonlocal", Nonlocal_type) < 0) return null;
    if (PyDict_SetItemString(d, "Expr", Expr_type) < 0) return null;
    if (PyDict_SetItemString(d, "Pass", Pass_type) < 0) return null;
    if (PyDict_SetItemString(d, "Break", Break_type) < 0) return null;
    if (PyDict_SetItemString(d, "Continue", Continue_type) < 0) return null;
    if (PyDict_SetItemString(d, "expr", expr_type) < 0) return null;
    if (PyDict_SetItemString(d, "BoolOp", BoolOp_type) < 0) return null;
    if (PyDict_SetItemString(d, "BinOp", BinOp_type) < 0) return null;
    if (PyDict_SetItemString(d, "UnaryOp", UnaryOp_type) < 0) return null;
    if (PyDict_SetItemString(d, "Lambda", Lambda_type) < 0) return null;
    if (PyDict_SetItemString(d, "IfExp", IfExp_type) < 0) return null;
    if (PyDict_SetItemString(d, "Dict", Dict_type) < 0) return null;
    if (PyDict_SetItemString(d, "Set", Set_type) < 0) return null;
    if (PyDict_SetItemString(d, "ListComp", ListComp_type) < 0) return null;
    if (PyDict_SetItemString(d, "SetComp", SetComp_type) < 0) return null;
    if (PyDict_SetItemString(d, "DictComp", DictComp_type) < 0) return null;
    if (PyDict_SetItemString(d, "GeneratorExp", GeneratorExp_type) < 0) return null;
    if (PyDict_SetItemString(d, "Await", Await_type) < 0) return null;
    if (PyDict_SetItemString(d, "Yield", Yield_type) < 0) return null;
    if (PyDict_SetItemString(d, "YieldFrom", YieldFrom_type) < 0) return null;
    if (PyDict_SetItemString(d, "Compare", Compare_type) < 0) return null;
    if (PyDict_SetItemString(d, "Call", Call_type) < 0) return null;
    if (PyDict_SetItemString(d, "Num", Num_type) < 0) return null;
    if (PyDict_SetItemString(d, "Str", Str_type) < 0) return null;
    if (PyDict_SetItemString(d, "FormattedValue", FormattedValue_type) < 0) return null;
    if (PyDict_SetItemString(d, "JoinedStr", JoinedStr_type) < 0) return null;
    if (PyDict_SetItemString(d, "Bytes", Bytes_type) < 0) return null;
    if (PyDict_SetItemString(d, "NameConstant", NameConstant_type) < 0) return null;
    if (PyDict_SetItemString(d, "Ellipsis", Ellipsis_type) < 0) return null;
    if (PyDict_SetItemString(d, "Constant", Constant_type) < 0) return null;
    if (PyDict_SetItemString(d, "Attribute", Attribute_type) < 0) return null;
    if (PyDict_SetItemString(d, "Subscript", Subscript_type) < 0) return null;
    if (PyDict_SetItemString(d, "Starred", Starred_type) < 0) return null;
    if (PyDict_SetItemString(d, "Name", Name_type) < 0) return null;
    if (PyDict_SetItemString(d, "List", List_type) < 0) return null;
    if (PyDict_SetItemString(d, "Tuple", Tuple_type) < 0) return null;
    if (PyDict_SetItemString(d, "expr_context", expr_context_type) < 0) return null;
    if (PyDict_SetItemString(d, "Load", Load_type) < 0) return null;
    if (PyDict_SetItemString(d, "Store", Store_type) < 0) return null;
    if (PyDict_SetItemString(d, "Del", Del_type) < 0) return null;
    if (PyDict_SetItemString(d, "AugLoad", AugLoad_type) < 0) return null;
    if (PyDict_SetItemString(d, "AugStore", AugStore_type) < 0) return null;
    if (PyDict_SetItemString(d, "Param", Param_type) < 0) return null;
    if (PyDict_SetItemString(d, "slice", slice_type) < 0) return null;
    if (PyDict_SetItemString(d, "Slice", Slice_type) < 0) return null;
    if (PyDict_SetItemString(d, "ExtSlice", ExtSlice_type) < 0) return null;
    if (PyDict_SetItemString(d, "Index", Index_type) < 0) return null;
    if (PyDict_SetItemString(d, "boolop", boolop_type) < 0) return null;
    if (PyDict_SetItemString(d, "And", And_type) < 0) return null;
    if (PyDict_SetItemString(d, "Or", Or_type) < 0) return null;
    if (PyDict_SetItemString(d, "operator", operator_type) < 0) return null;
    if (PyDict_SetItemString(d, "Add", Add_type) < 0) return null;
    if (PyDict_SetItemString(d, "Sub", Sub_type) < 0) return null;
    if (PyDict_SetItemString(d, "Mult", Mult_type) < 0) return null;
    if (PyDict_SetItemString(d, "MatMult", MatMult_type) < 0) return null;
    if (PyDict_SetItemString(d, "Div", Div_type) < 0) return null;
    if (PyDict_SetItemString(d, "Mod", Mod_type) < 0) return null;
    if (PyDict_SetItemString(d, "Pow", Pow_type) < 0) return null;
    if (PyDict_SetItemString(d, "LShift", LShift_type) < 0) return null;
    if (PyDict_SetItemString(d, "RShift", RShift_type) < 0) return null;
    if (PyDict_SetItemString(d, "BitOr", BitOr_type) < 0) return null;
    if (PyDict_SetItemString(d, "BitXor", BitXor_type) < 0) return null;
    if (PyDict_SetItemString(d, "BitAnd", BitAnd_type) < 0) return null;
    if (PyDict_SetItemString(d, "FloorDiv", FloorDiv_type) < 0) return null;
    if (PyDict_SetItemString(d, "unaryop", unaryop_type) < 0) return null;
    if (PyDict_SetItemString(d, "Invert", Invert_type) < 0) return null;
    if (PyDict_SetItemString(d, "Not", Not_type) < 0) return null;
    if (PyDict_SetItemString(d, "UAdd", UAdd_type) < 0) return null;
    if (PyDict_SetItemString(d, "USub", USub_type) < 0) return null;
    if (PyDict_SetItemString(d, "cmpop", cmpop_type) < 0) return null;
    if (PyDict_SetItemString(d, "Eq", Eq_type) < 0) return null;
    if (PyDict_SetItemString(d, "NotEq", NotEq_type) < 0) return null;
    if (PyDict_SetItemString(d, "Lt", Lt_type) < 0) return null;
    if (PyDict_SetItemString(d, "LtE", LtE_type) < 0) return null;
    if (PyDict_SetItemString(d, "Gt", Gt_type) < 0) return null;
    if (PyDict_SetItemString(d, "GtE", GtE_type) < 0) return null;
    if (PyDict_SetItemString(d, "Is", Is_type) < 0) return null;
    if (PyDict_SetItemString(d, "IsNot", IsNot_type) < 0) return null;
    if (PyDict_SetItemString(d, "In", In_type) < 0) return null;
    if (PyDict_SetItemString(d, "NotIn", NotIn_type) < 0) return null;
    if (PyDict_SetItemString(d, "comprehension", comprehension_type) < 0) return null;
    if (PyDict_SetItemString(d, "excepthandler", excepthandler_type) < 0) return null;
    if (PyDict_SetItemString(d, "ExceptHandler", ExceptHandler_type) < 0) return null;
    if (PyDict_SetItemString(d, "arguments", arguments_type) < 0) return null;
    if (PyDict_SetItemString(d, "arg", arg_type) < 0) return null;
    if (PyDict_SetItemString(d, "keyword", keyword_type) < 0) return null;
    if (PyDict_SetItemString(d, "alias", alias_type) < 0) return null;
    if (PyDict_SetItemString(d, "withitem", withitem_type) < 0) return null;
    return m;
};


var PyAST_mod2obj = function(t) {
    if (!init_types()) {
        return null;
    }
    return ast2obj_mod(t);
};

/* mode is 0 for "exec", 1 for "eval" and 2 for "single" input */
var PyAST_obj2mod = function(ast, mode) {
    var res;
    var req_type = [null, null, null];
    var req_name = ["Module", "Expression", "Interactive"];
    var isinstance;

    req_type[0] = Module_type;
    req_type[1] = Expression_type;
    req_type[2] = Interactive_type;

    if (!init_types())
        return null;

    isinstance = PyObject_IsInstance(ast, req_type[mode]);
    if (isinstance == -1)
        return null;
    if (!isinstance) {
        throw new batavia.builtins.TypeError("expected " + req_name[mode] + " node, got " + Py_TYPE(ast).tp_name);
    }
    if (obj2ast_mod(ast, res) != 0) {
        return null;
    } else {
        return res;
    }
};

var ast_check = function(obj) {
    if (!init_types()) {
        return -1;
    }
    return batavia.isinstance(obj, AST_object);
};

batavia.modules.ast.ast_check = ast_check;

}()); // don't execute the module yet until it works better


